<?page
title=><?_ml .title _ml?>
body<=

<?_code 
{
    use strict;
    use vars qw(%POST);

    my $dbh = LJ::get_db_writer();
    my $u = LJ::get_remote();

    unless ($u) {
        return "<?h1 $ML{'.loginrequired.title'} h1?><?p $ML{'.loginrequired.text'} p?>";
    }
    return "<?h1 $ML{'error.suspended.title'} h1?><?p $ML{'error.suspended.text'} p?>" if $u->{'statusvis'} eq "S";

    my $quota = LJ::get_cap($u, "synd_quota");
    unless ($quota) {
        return "<?h1 $ML{'Sorry'} h1?><?p $ML{'.accountype.notallowed'} p?>";
    }

    if (LJ::did_post() && $POST{'userid'} != $u->{'userid'}) {
        return "<?h1 $ML{'.invalid.submission'} h1?><?p $ML{'.user.nomatch'} p?>";
    }

    my $sth = $dbh->prepare("SELECT s.userid, us.user, s.synurl, COUNT(*) ".
                            "FROM useridmap us, syndicated s, friends fa, friends fb ".
                            "WHERE fa.userid=? AND fa.friendid=s.userid AND us.userid=s.userid ".
                            "AND fb.friendid=s.userid GROUP BY 1, 2, 3");
    $sth->execute($u->{'userid'});
    my $used = 0;
    my %count;
    my %cost;
    my %syn;
    while (my ($suserid, $user, $url, $count) = $sth->fetchrow_array) {
        if ($POST{'action:remove'} && $POST{"defriend_$user"}) {
            LJ::friends_do($u, "DELETE FROM friends WHERE userid=? AND friendid=?",
                           $u->{'userid'}, $suserid);
            next;
        }
        $count{$user} = $count;
        $cost{$user} = LJ::syn_cost($count);
        $used += $cost{$user};
        $syn{$user} = $url;
    }

    my $error = sub {
        return "<?h1 $ML{'Error'} h1?><?p $_[0] p?><?p " .
                BML::ml('Backlink', {'link' => '/syn/', 'text' => $ML{'.back'}}) . " p?>";
    };
    
    # add custom feed
    if ($POST{'action:addcustom'}) {
        my $acct = $POST{'acct'};
        my $url = $POST{'synurl'};

        if ($acct ne "") {
            return $error->($ML{'.invalid.accountname'})
                unless $acct =~ /^\w{3,15}$/;
            foreach my $re ("^system\$", @LJ::PROTECTED_USERNAMES) {
                next unless ($acct =~ /$re/);
                return $error->($ML{'.invalid.reserved'});
            }
        }
        if ($url ne "") {
            return $error->($ML{'.invalid.url'})
                unless $url =~ m!^http://(.+?)/!;
            my $hostname = $1;
            return $error->($ML{'.invalid.cantadd'})
                if $hostname =~ /\Q$LJ::DOMAIN\E/i;
            return $error->($ML{'.invalid.port'})
                if $hostname =~ /:/;
            return $error->($ML{'.invalid.address'})
                unless $hostname =~ /\.[a-z]/i;
        }

        my $su;  # account to add
        if ($url) {
            $su = $dbh->selectrow_hashref("SELECT u.user, s.* FROM syndicated s, useridmap u ".
                                          "WHERE s.synurl=? AND s.userid=u.userid",
                                          undef, $url);
            
            unless ($su) {
                return "<?h1 $ML{'.invalid.overquota.title'} h1?><?p $ML{'.invalid.overquota.text'} p?>"
                    if $used+1 > $quota;
                
                return "<?h1 $ML{'.invalid.needname.title'} h1?><?p $ML{'.invalid.needname.text'} p?>"
                    unless $acct;
                
                # MAYBE: see if it actually points to a valid syndication file
                # naah, too much work here.  just let synsuck.pl detect its
                # bogosity and delete it.
                my $id = LJ::create_account({
                    'user' => $acct,
                    'name' => $acct,
                    'password' => '',
                    'caps' => $LJ::SYND_CAPS,
                    'cluster' => $LJ::SYND_CLUSTER,
                });
                return "<?h1 $ML{'.invalid.inuse.title'} h1?><?p $ML{'.invalid.inuse.text'} p?>"
                    unless $id;

                LJ::update_user($id, { journaltype => 'Y' });
                $dbh->do("INSERT INTO syndicated (userid, synurl, checknext) VALUES (?,?,NOW())",
                         undef, $id, $url);

                LJ::statushistory_add($u->{'userid'}, $id, "synd_create", "acct: $acct");

                $su = $dbh->selectrow_hashref("SELECT u.user, s.* FROM syndicated s, useridmap u ".
                                              "WHERE s.userid=? AND s.userid=u.userid",
                                              undef, $id);
            }
        } elsif ($acct) {
            $su = $dbh->selectrow_hashref("SELECT u.user, s.* FROM syndicated s, useridmap u ".
                                          "WHERE u.userid=s.userid AND u.user=?",
                                          undef, $acct);
            unless ($su) {
                return $error->($ML{'.invalid.notexist'});
            }
        } else {
            return $error->($ML{'.invalid.needurl'});
        }
        
        return $error->($ML{'.error.unknown'}) unless $su;
        unless ($cost{$su->{'user'}}) 
        {
            my $count = $dbh->selectrow_array("SELECT COUNT(*) FROM friends WHERE friendid=?", undef,
                                              $su->{'userid'});
            $count = $count + 1;
            my $cost = LJ::syn_cost($count);
            if ($used + $cost > $quota) {
                return "<?h1 $ML{'Sorry'} h1?><?p $ML{'.invalid.overquota'} p?><?p " .
                        BML::ml('Backlink', {'link' => '/syn/', 'text' => $ML{'.back'}}) . " p?>";
            }
            LJ::add_friend($u->{'userid'}, $su->{'userid'}, { 'defaultview' => 1 });
            $count{$su->{'user'}} = $count;
            $cost{$su->{'user'}} = $cost;
            $syn{$su->{'user'}} = $su->{'synurl'};
            $used += $cost;
        }
    }

    # get 100 most popular feeds from memcache
    my $popsyn = LJ::MemCache::get("popsyn");

    # nothing in memcache, build an object from db
    # then populate memcache
    unless ($popsyn) {
        $popsyn = [];

        my $sth = $dbh->prepare("SELECT userid, synurl, numreaders FROM syndicated " .
                                "ORDER BY numreaders DESC LIMIT 100");
        $sth->execute();
        while (my @row = $sth->fetchrow_array) {
            push @$popsyn, [ @row ];
        }

        # load u objects so we can get usernames
        my %users;
        LJ::load_userids_multiple([ map { $_, \$users{$_} } map { $_->[0] } @$popsyn ], [$u]);
        unshift @$_, $users{$_->[0]}->{'user'} foreach @$popsyn;

        # format is: [ user, userid, synurl, numreaders ]

        # set in memcache
        my $expire = time() + 3600; # 1 hour
        LJ::MemCache::set("popsyn", $popsyn, $expire);        
    }

    # load user's friends so we can strip feeds they already watch
    my $friends = LJ::get_friends($u) || {};

    # populate @pop and add users they've chosen to add
    my @pop;
    foreach (@$popsyn) {
        my ($user, $suserid, $url, $count) = @$_;

        my $suser = LJ::load_userid($suserid);
        # skip suspended/deleted accounts, already watched feeds
        next if ($friends->{$suserid} || ($suser->{'statusvis'} ne "V"));

        my $cost = LJ::syn_cost($count + 1);
        if ($POST{'action:add'} && $POST{"add_$user"}) {
            if ($used + $cost < $quota) {
                LJ::add_friend($u->{'userid'}, $suserid, { 'defaultview' => 1 });
                $count{$user} = $count+1;
                $cost{$user} = $cost;
                $syn{$user} = $url;
                $used += $cost;
            } else {
                return "<?h1 $ML{'Sorry'} h1?><?p " . BML::ml ('.invalid.overquota.username', {'user' => LJ::ljuser($user)}) . " p?><?p " .
                        BML::ml('Backlink', {'link' => '/syn/', 'text' => $ML{'.back'}}) . " p?>";
            }
        } else {
            push @pop, [ $user, $url, $count ];
            last if @pop >= 20;
        }
    }

    # intro paragraph
    my $title = BML::ml('.using.title', {'sitename' => $LJ::SITENAME});
    my $ret = "<?h1 $title h1?><?p $ML{'.using.text'} p?>" .
              "<?p $ML{'.quota.text'} p?><?p $ML{'.promo.text'} p?>";

    $used = sprintf("%0.03f", $used);
    $quota = sprintf("%0.03f", $quota);
    $ret .= "<?h1 $ML{'.quota.your'} h1?><?p " . BML::ml('.quota.numbers', {'used' => $used, 'total' => $quota}) . " p?>";

    $ret .= "<form method='post' action='./'>"; 
    $ret .= LJ::html_hidden("userid", $u->{'userid'});

    if ($used) {
        $ret .= "<p><table cellpadding='3' style='margin-bottom: 10px;'>";
        $ret .= "<tr><td></td><td><b>$ML{'.table.account'}</b></td><td><b>$ML{'.table.feed'}</b></td>";
        $ret .= "<td align='right'><b>$ML{'.table.watchers'}</b></td><td align='right'><b>$ML{'.table.cost'}</b></td></tr>\n";
        foreach my $user (sort { $count{$a} <=> $count{$b} } keys %count) {
            $ret .= "<tr>";
            $ret .= "<td><input type='checkbox' value='1' name='defriend_$user' /></td>";
            $ret .= "<td>" . LJ::ljuser($user) . "</td>";
            $ret .= "<td><a href=\"$syn{$user}\">$syn{$user}</a></td>";
            $ret .= "<td align='right'>$count{$user}</td><td align='right'>";
            $ret .= sprintf("%.03f", $cost{$user});
            $ret .= "</td>";
            $ret .= "</tr>";
        }
        $ret .= "<tr><td align='left' colspan='4'>";
        $ret .= "<input type='submit' name='action:remove' value='" . LJ::ehtml($ML{'.remove'}) . "' />";
        $ret .= "</td></tr>";
        $ret .= "</table>";
    }

    if (@pop) {
        $ret .= "<?h1 $ML{'.add.pop.title'} h1?><?p $ML{'.add.pop.text'} p?>";
        $ret .= "<p><table cellpadding='3' style='margin-bottom: 10px;'>";
        $ret .= "<tr><td></td><td><b>$ML{'.table.account'}</b></td><td><b>$ML{'.table.feed'}</b></td>";
        $ret .= "<td><b>$ML{'.table.watchers'}</b></td><td><b>$ML{'.table.cost'}</b></td></tr>";
        foreach (@pop) {
            my ($user, $url, $count) = @$_;
            my $cost = LJ::syn_cost($count + 1);  # plus one because we're including ourselves, friendof-to-be
            $ret .= "<tr>";
            $ret .= "<td><input type='checkbox' value='1' name='add_$user' /></td>";
            $ret .= "<td>" . LJ::ljuser($user) . "</td>";
            $ret .= "<td><a href=\"$url\">$url</a></td>";
            $ret .= "<td align='right'>$count</td><td align='right'>";
            $ret .= sprintf("%.03f", $cost);
            $ret .= "</td>";
            $ret .= "</tr>";
        }
        $ret .= "<tr><td align='left' colspan='4'>";
        $ret .= "<input type='submit' name='action:add' value='" . LJ::ehtml($ML{'.add'}) . "'>";        
        $ret .= "</td></tr>";
        $ret .= "</table>";
    }

    $ret .= "<?h1 $ML{'.add.other.title'} h1?><?p $ML{'.add.other.text'} p?>";
    $ret .= "<blockquote>$ML{'.account'} <input size='15' maxlength='15' name='acct' /> <i>$ML{'.notused'}</i>";
    $ret .= "<p>$ML{'.feed.url'} <input size='40' maxlength='255' name='synurl' />";
    $ret .= "<p><input name='action:addcustom' type='submit' value='" . LJ::ehtml($ML{'.add'}) . "' /></blockquote>";

    $ret .= "</form>";

    return $ret;
}
_code?>

<=body
page?>
