<?_code
{
    use strict;
    use vars qw(%GET %POST $title $body $head @errors);
    use Carp qw(croak);
    use Archive::Zip;
    use Digest::SHA1 qw(sha1_hex);
    use IO::String;

    BML::set_language_scope("/customize/uploadstyle.bml");

    $title = $ML{'.title2'};
    $body = "";
    @errors = ();

    my $suffix;
    my $zip_contents;

    my $err = sub {
        $title = $ML{'Error'};
        $body = LJ::bad_input(@_);
        return;
    };

    unless (LJ::text_in(\%POST)) {
        return $err->("Invalid UTF-8 Input");
    }

    my $remote = LJ::get_remote();
    unless ($remote) {
        $body = "<?needlogin?>";
        return;
    }

    if ($remote->underage) {
        return BML::redirect("$LJ::SITEROOT/agecheck/?s=1");
    }

    LJ::need_res('stc/lj_base.css');
    LJ::need_res('stc/editpics.css');
    $head .= q {
      <script language="JavaScript" src="/js/core.js"></script>
      <script language="JavaScript" src="/js/dom.js"></script>
      <script language="JavaScript" src="/js/progressbar.js"></script>
      <script language="JavaScript" src="/js/ljprogressbar.js"></script>
      <script language="JavaScript" src="/js/perlbal-uploadtrack.js"></script>
      <script language="JavaScript" src="/js/editpics.js"></script>
    };

    my $authas = $GET{'authas'} || $remote->{'user'};
    my $u = LJ::get_authas_user($authas) or
        return $err->("a".$ML{'error.invalidauth'});

    if (LJ::get_cap($u, "readonly")) {
        $title = "Read-only mode";
        $body = $LJ::MSG_READONLY_USER;
        return;
    }

    # extra arguments for get requests
    my $getextra = $authas ne $remote->{'user'} ? "?authas=$authas" : '';

    my $returl = LJ::CleanHTML::canonical_url($POST{'ret'});

    # for layer access (taken from options.bml)
    my $pub = LJ::S2::get_public_layers();
    my $userlay = LJ::S2::get_layers_of_user($u); #Hash of my layers
    my %s2_style = LJ::S2::get_style($u, "verify"); #current layers used by user
    my $has_cap = LJ::get_cap($u, "s2styles");
    my ($style, $layer, $lyr_layout, $lyr_core, @layerids, %layerinfo, $lid_i18nc, $lid_theme, $lid_i18n, $layerid);
    my %params = (authas           => 'word',
                  opt_usesharedpic => qr/./,
                  s1_overrides     => qr/./,
                  'action:redir'   => 'word',
                  'action:remove'  => qr/./,
                  'lj_form_auth'   => qr/./,);
    
    my $css_contents;
    my $lastmember;

# TODO: Get max space quota here.

    ### save mode
    if (LJ::did_post()) {
    
        ### no post data, so we'll parse the multipart data
        unless (%POST) {

            my $r = Apache->request;
            my $size = $r->header_in("Content-length");
            unless ($size) {
                return $err->("No content-length header: can't upload");
            }
            
            #1 MB. Should be a variable we pull in from ljconfig.pl
            my $MAX_UPLOAD = 1048576;
            my $error;

            # file over 1MB, return too large error
            # (not sure why we're adding 2048, but editpics did that)
            if ($size > $MAX_UPLOAD + 2048) {
                # we have to suck in the data otherwise the browser gets upset because we're
                # closing the connection before reading in all the data and it will sometimes
                # refuse to show the error.

                # pretend to tell apache that we care about parsing the data, but we really don't
                my $bogus = sub {return 1;};
                BML::parse_multipart_interactive($r, \$error, {
                    newheaders => $bogus,
                    data       => $bogus,
                    enddata    => $bogus,
                });

                return $err->(BML::ml('.error.filetoolarge',
                                      { 'maxsize' => int($MAX_UPLOAD / 1048576) .
                                            $ML{'.megabytes'} }));
            }

            # Set everything up to use parse_multipart_interactive
            my $io_string = undef;
            my $curr_name = '';
            my $valid_magic = 0;
            
            my $hook_newheaders = sub {
                my ($name, $filename) = @_;
                
                $POST{$name} = '';
                $curr_name = $name; # for keeping state
                
                return 1 unless ($name eq 'zip');
                
                # now we know we're processing the expected file upload
                $io_string = new IO::String;
                
                return 1;
            };
            
            my $hook_data = sub {
                my ($len, $data) = @_;
                
                unless ($curr_name eq 'zip') {
                    $POST{$curr_name} .= $data;
                    die "this shouldn't be so long...?"
                        if length $data > (1<<20); #1MB.  Dies with 1KB?
                    return 1;
                }
                
                # now we know we're processing the file upload
                
                #check for magic bits, if we haven't already done so
                # (and if there's data to check)
                unless ($io_string->tell < 4 || $valid_magic) {
                    my $pos = $io_string->getpos;
                    $io_string->seek(0,0); #set position to head of file
                    
                    my $magic;
                    $io_string->read($magic, 4);
                    die "Doesn't look like a valid zip: found '$magic'"
                        unless $magic =~ /^\x50\x4B\x03\x04/;
                    $io_string->setpos($pos); #restore position
                    $valid_magic = 1;
                }
                
                $io_string->print($data); # or whatever
                
                # have we already read too much?
                if ($io_string->tell > $MAX_UPLOAD) { # 1mb or so?
                    die "maximum upload exceeded";
                }
                
                return 1;
            };
            
            my $hook_enddata = sub {
                
                # nothing to do on normal post elements
                return 1 unless ($curr_name eq 'zip');
                
                # since we've just finished a potentially slow upload, we need to make
                # sure the database handles in DBI::Role's cache haven't expired,
                # so we'll just trigger a revalidation now so that subsequent database
                # calls will be safe.
                $LJ::DBIRole->clear_req_cache();
            
                # no filehandles to close or anything, this is an IO::String!
            };
            
            # now actually call the parse_multipart_interactive to fill out $io_string
            my $res = eval {
               BML::parse_multipart_interactive
                  ($r, \$error, {
                                   newheaders => $hook_newheaders,
                                   data       => $hook_data,
                                   enddata    => $hook_enddata,
                                });
            };
            
            if ($io_string->tell < 4){
                die "File too short!";
            }
        
            if (!$valid_magic) { #still haven't checked magic bits?!
                my $pos = $io_string->getpos;
                $io_string->seek(0,0); #set position to head of file
                
                my $magic;
                $io_string->read($magic, 4);
                die "Doesn't look like a valid zip: found '$magic'"
                    unless $magic =~ /^\x50\x4B\x03\x04/;
                $io_string->setpos($pos); #restore position
                $valid_magic = 1;
            }
            
            unless ($res) {
                # should be fancier than this, but basically:
                
                #TODO: parse and/or push errors into @errors
                return "Error: $@";
            }

            if ($io_string) { 
                my $zip = Archive::Zip->new();
                my $status = $zip->readFromFileHandle( $io_string );
                if ($zip->eocdOffset()){
                    warn "Something has added ", $zip->eocdOffset, " bytes of garbage!\n";
                }
                
                # Roundabout way of doing this; there's got to be some alternative method...
                foreach my $pathname ($zip->memberNames()){
                    my $filename = $pathname;
                    $filename =~ s|.*/(.*?)$|$1|;
                    if (!($pathname =~ /MACOSX/) && $filename =~ /^style.css$/i){
                        $css_contents = $zip->contents($pathname);
                    }
                    last if defined $css_contents;
                }
                
                # FIXME: wizard-voxhtml is hardcoded in here.  Should probably change this.
                my $styleid = $u->selectrow_array("SELECT styleid FROM s2styles "
                        ."WHERE userid='".$u->{'userid'}."' AND name='wizard-voxhtml'");
                
                # clean $css_contents and fix image links.
                unless ($LJ::DISABLED{'css_cleaner'}) {
                    my $cleaner = CSS::Cleaner->new;
                    $css_contents = $cleaner->clean($css_contents);
                    if ($LJ::IS_DEV_SERVER) {
                        $css_contents = "/* cleaned in uploadstyle */\n" . $css_contents;
                    }
                }
                my $base = $u->journal_base;
                $css_contents =~ s!images/(.+?\.(?:jpg|gif|png|jpeg))!$base/res/$styleid/$1!ig;
                
                #  (code from /customize/options.bml)
                unless ($s2_style{'user'}) {
                    $s2_style{'user'} = LJ::S2::create_layer($u->{userid}, $s2_style{'layout'}, "user");
                    return "<?h1 $ML{'Error'} h1?> <?p $ML{'.error.cant_generate_user_layer'} p?>"
                        unless $s2_style{'user'};
                }
                
                LJ::cmize::s2_implicit_style_create($u, %s2_style);
                
                $style = LJ::S2::load_style($u->prop('s2_style'));
                return $err->("Style not found.") unless $style && $style->{'userid'} == $u->{'userid'};
                $layer = LJ::S2::load_layer($style->{'layer'}->{'user'});
                
                # if the b2lid of this layer has been remapped to a new layerid
                # then update the b2lid mapping for this layer
                my $b2lid = $layer->{b2lid};
                if ($b2lid && $LJ::S2LID_REMAP{$b2lid}) {
                    LJ::S2::b2lid_remap($u, $style->{'layer'}->{'user'}, $b2lid);
                    $layer->{b2lid} = $LJ::S2LID_REMAP{$b2lid};
                }
                
                return $err->("Layer belongs to another user. $layer->{userid} vs $u->{userid}") unless $layer->{'userid'} == $u->{'userid'};
                return $err->("Layer isn't of type user or theme.")
                    unless $layer->{'type'} eq "user" || $layer->{'type'} eq "theme";

                my $dbh = LJ::get_db_writer();
                $lyr_layout = LJ::S2::load_layer($dbh, $layer->{'b2lid'});
                return $err->("Layout layer for this $layer->{'type'} layer not found.")
                    unless $lyr_layout;
                $lyr_core = LJ::S2::load_layer($dbh, $lyr_layout->{'b2lid'});
                return $err->("Core layer for layout not found.")
                    unless $lyr_core;
            
                $lyr_layout->{'uniq'} = $dbh->selectrow_array("SELECT value FROM s2info WHERE s2lid=? AND infokey=?",
                            undef, $lyr_layout->{'s2lid'}, "redist_uniq");
                            
                $lid_i18nc = $style->{'layer'}->{'i18nc'};
                $lid_theme = $style->{'layer'}->{'theme'};
                $lid_i18n = $style->{'layer'}->{'i18n'};
        
                $layerid = $layer->{'s2lid'};
        
                my @layers;
                push @layers, ([ 'core' => $lyr_core->{'s2lid'} ],
                               [ 'i18nc' => $lid_i18nc ],
                               [ 'layout' => $lyr_layout->{'s2lid'} ],
                               [ 'i18n' => $lid_i18n ]);
                if ($layer->{'type'} eq "user" && $lid_theme) {
                    push @layers, [ 'theme' => $lid_theme ];
                }
                push @layers, [ $layer->{'type'} => $layer->{'s2lid'} ];
        
                @layerids = grep { $_ } map { $_->[1] } @layers;
                LJ::S2::load_layers(@layerids);
        
                # load the language and layout choices for core.
                LJ::S2::load_layer_info(\%layerinfo, \@layerids);
        
                foreach my $prop (S2::get_properties($lyr_layout->{'s2lid'}))
                {
                    $prop = S2::get_property($lyr_core->{'s2lid'}, $prop) unless ref $prop;
                    next unless ref $prop;
                    next unless LJ::S2::can_use_prop($u, $lyr_layout->{'uniq'}, $prop->{'name'});
                    $params{"s2_" . $prop->{'name'} . "_value"} = qr/./;
                }

                BML::decl_params(%params);
                ### /end copied code
                
                $zip_contents .= "Installing custom_css!<BR>";
                
                my %orig_override;
                my %override;
                my $customized;
                foreach my $prop (S2::get_properties($lyr_layout->{'s2lid'}))
                {
                    $prop = S2::get_property($lyr_core->{'s2lid'}, $prop)
                        unless ref $prop;
                    next unless ref $prop;
                    next if $prop->{'noui'};
                    my $name = $prop->{'name'};
                    next unless LJ::S2::can_use_prop($u, $lyr_layout->{'uniq'}, $name);

                        # figure out existing value (if there was no user/theme layer)
                        LJ::S2::load_layers(@layerids);
                        my $existing;
                        foreach my $lid (reverse @layerids) {{
                            next if $lid == $layer->{'s2lid'};
                            $existing = S2::get_set($lid, $name);
                            last if defined $existing;
                        }}
            
                        if (ref $existing eq "HASH") {
                            $existing = $existing->{'as_string'};
                        }
                        
                        $customized = S2::get_set($layer->{'s2lid'}, $name);
                        $customized = $existing unless defined $customized;
                        $override{$name} = [ $prop, $customized ];
                        $orig_override{$name} = [ $prop, $customized ];

                    if ($name eq 'custom_css'){
                        $override{$name} = [ $prop, $css_contents ];
                    }
                    
                    $zip_contents .= "$name=".LJ::D($customized)."<BR>\n";
                }
                if (! LJ::S2::layer_compile_user($layer, \%override)) {
                    return $err->("Failed while trying to save your css file. $zip_contents");
                }
                LJ::S2::load_layers($layerid);
                
                LJ::S2res->backup($u);
                # Store images
                foreach my $pathname ($zip->memberNames()){
                    my $filename = $pathname;
                    $filename =~ s|.*/(.*?)$|$1|;
                    if (!($pathname =~ /MACOSX/) && $filename =~ /\.(?:jpg|gif|png|jpeg)$/i){
                        $zip_contents .= "<B>$filename ($pathname)</B>\n";
                        
                        my $fh = IO::String->new();
                        $fh->print($zip->contents($pathname));
                        $fh->seek(0,0);
                        $fh->read(my $magic, 4);
                        
                        my $format_magic = sub {
                            my $magic = shift;
                            my $hex = unpack "H*", $magic;
                            my $mime;
    
                            # image formats
                            $mime = 'image/jpeg' if $magic =~ /^\xff\xd8/; # JPEG
                            $mime = 'image/gif'  if $magic =~ /^GIF8/;     # GIF
                            $mime = 'image/png'  if $magic =~ /^\x89PNG/;  # PNG
    
                            return $mime;
                        };
    
                        my $mime = $format_magic->($magic); #check image formats
                        
                        if ($mime){
                            $zip_contents .= "...[magic:$magic]recognized as $mime<BR>\n";
                            my $data = $zip->contents($pathname);
                            my $resid = eval {
                                    LJ::S2res->create($u, 
                                            data => \$data, 
                                            filename => $filename,
                                            styleid => $styleid); 
                                };
                            if (!$resid) {
                                LJ::S2res->restore($u);
                                if (! LJ::S2::layer_compile_user($layer, \%orig_override)) {
                                    return $err->("Failed while trying to restore your css file. $zip_contents");
                                }
                                return $err->($@);
                            }
                            $zip_contents .= $resid; 
                        }
                    }
                }
                LJ::S2res->cleanup($u);
                
            } else {
                $zip_contents .= "no io_string?";
            }
        }
    }


##Print out stuff

    # authas switcher form
    $body .= "<form method='get' action='uploadstyle$suffix.bml'>\n";
    $body .= LJ::make_authas_select($remote, { 'authas' => $GET{'authas'} }) . "\n";
    $body .= "</form>\n\n";

    # if we're disabling media, say so
    $body .= "<?warningbar $ML{'error.mediauploadsdisabled'} warningbar?>"
        if $LJ::DISABLE_MEDIA_UPLOADS;

    if (@errors) {
        $body .= LJ::error_list(@errors);
    }

    # print out upload pic box
    my $emit_upload_box = sub {
        $body .= '<a name="uploadBox"></a>';
        $body .= "<?h1 $ML{'.uploadheader'} h1?>\n";
        $body .= "<?p $ML{'.uploaddesc'} p?>\n";

        # upload form (with perlbal upload-tracking)
        $body .= qq {
            <iframe name='upiframe' width='1' height='1' style='border: none'></iframe>
                <?standout
                <form enctype="multipart/form-data" action="uploadstyle$suffix.bml$getextra"
                method='post' id='uploadZip'>
                <input type="hidden" id="go_to" name="go_to" value="uploadstyle$suffix.bml$getextra" />

                <table>
            };

        $body .= "<tr><td align='right'>";
        $body .= "<label for='radio_file'>$ML{'.fromfile'}</label></td>";
        $body .= "<td align='left'><input type='file' name='zip' size='28' /></td></tr>\n";

        $body .= "<tr><td colspan='3' align='center'>";
        $body .= LJ::html_submit(undef, $ML{'.btn.proceed'},
                                 { disabled => $LJ::DISABLE_MEDIA_UPLOADS });
        $body .= q {
            </td>
                </tr>
                </table>
                </form>
                <div id="uploadStatus" style="display: none;"></div>
                <div id="progressBar" style="display: none;"></div>
            };

        $body .= " standout?>\n\n";
    };

    $emit_upload_box->();

### print out contents of zip:
    $body .= $zip_contents;
    $body .= $lastmember;

    return;
}

_code?><?page
    head=><?_code return $head; _code?>
    title=><?_code return $title; _code?>
    body=><?_code return $body; _code?>
    page?><?_c <LJDEP>
link: htdocs/login.bml
post: htdocs/customize/uploadstyle.bml
    </LJDEP> _c?>
