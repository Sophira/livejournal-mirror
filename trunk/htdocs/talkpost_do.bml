<?page
title=><?_code return $POST{'submitpreview'} ? $ML{'.title.preview'} : $ML{'.title'}; _code?>
body<=

<?_code
{
    use strict;
    use vars qw(%POST %ML %GET);

    # stupid hack to allow hotmail people to post, since hotmail changes
    # POST forms to GET.  this isn't a security problem (GET -> POST escalation)
    # since talklib.pl's LJ::Talk::Post::init checks for $POST{'ecphash'}
    # and requires it to be correct.  if it's not, the page fails.
    %POST = %GET if $GET{'ecphash'};

    my $req = shift;
    my $r = $req->{'r'};

    foreach my $re (@LJ::TALKSPAM) {
        return if ($POST{'body'} =~ /$re/);
    }

    return LJ::server_down_html() if $LJ::SERVER_DOWN;

    # normally require POST.  if an ecphash is specified, we'll let
    # them through since they're coming from a comment page and
    # validate the hash later.
    return "Comment not posted: POST required, or missing parameter." unless LJ::did_post() || $POST{'ecphash'};

    # as an exception, we do NOT call LJ::text_in() to check for bad
    # input, since it may be not in UTF-8 in replies coming from mail
    # clients. We call it later.

    my $remote_ip = LJ::get_remote_ip();
    if ($POST{'usertype'} eq "anonymous" && LJ::is_open_proxy($remote_ip)) {
        return "Your IP address ($remote_ip) is detected as an open proxy (a common source of spam) so comment access is denied.  If you do not believe you're accessing the net through an open proxy, please contact your ISP or this site's tech support to help resolve the problem.";
    }

    my $remote = LJ::get_remote();
    my $journalu = LJ::load_user($POST{journal});
    return 'Unknown journal.  Please go back and try again.' unless $journalu;

    ## preview
    # ignore errors for previewing
    if ($POST{'submitpreview'}) {
        my $cookie_auth;
        $cookie_auth = 1 if $POST{usertype} eq "cookieuser";
        my $talkurl = LJ::journal_base($journalu) . "/$POST{itemid}.html";
        return LJ::Talk::Post::make_preview($talkurl, $cookie_auth, \%POST);
    }

    # check anonymous rate limits
    my $do_captcha =
        $LJ::HUMAN_CHECK{anonpost} &&
        ! LJ::Talk::Post::check_rate($remote,
                                     $POST{'usertype'} eq 'anonymous');

    ## init.  this handles all the error-checking, as well.
    my @errors;
    my $init = LJ::Talk::Post::init(\%POST, $remote, $do_captcha, \@errors);

    # Report errors in a friendly manner by regenerating the field.
    # Required for challenge/response login, since we also need to regenerate an auth token.
    # We repopulate what we can via hidden fields - however the objects (journalu & parpost) must be recreated here.
    if (! $init) {
        my ($sth, $parpost);
        my $dbcm = LJ::get_cluster_master($journalu);
        return 'No database connection present.  Please go back and try again.' unless $dbcm;

        $sth = $dbcm->prepare("SELECT posterid, state FROM talk2 ".
                              "WHERE journalid=? AND jtalkid=?");
        $sth->execute($journalu->{userid}, $POST{itemid}+0);
        $parpost = $sth->fetchrow_hashref;
        
        return LJ::Talk::talkform({ 'remote'     => $remote,
                                    'journalu'   => $journalu,
                                    'parpost'    => $parpost,
                                    'replyto'    => $POST{replyto},
                                    'ditemid'    => $POST{itemid},
                                    'do_captcha' => $do_captcha,
                                    'errors'     => \@errors,
                                    'form'       => \%POST });
    }

    my $talkurl = $init->{talkurl};

    my $entryu   = $init->{entryu};
    my $journalu = $init->{journalu};
    my $parent   = $init->{parent};
    my $comment  = $init->{comment};
    my $item     = $init->{item};

    ## insertion
    my $wasscreened = ($parent->{state} eq 'S');
    my $err;
    unless (LJ::Talk::Post::post_comment($entryu, $journalu,
                                         $comment, $parent, $item, \$err)) {
        return $err;
    }

    # Yeah, we're done.
    my $dtalkid = $comment->{talkid}*256 + $item->{anum};
    my $commentlink = LJ::Talk::talkargs($talkurl, "view=$dtalkid") . "#t$dtalkid";

    my $ret = "";
    $ret .= "<?h1 $ML{'.success.title'} h1?>";

    my $mlcode;
    if ($comment->{state} eq 'A') {
        $mlcode = '.success.message';
    } else {
        # otherwise, it's a screened comment.
        if ($journalu->{'journaltype'} eq 'C') {
            $mlcode = $POST{'usertype'} eq 'anonymous' ? '.success.screened.comm.anon'
                                                       : '.success.screened.comm';
        } else {
            $mlcode = $POST{'usertype'} eq 'anonymous' ? '.success.screened.user.anon'
                                                       : '.success.screened.user';
        }
    }

    $ret .= "<?p " . BML::ml($mlcode, { 'link' => $commentlink }) . " p?>";

    # did this comment unscreen its parent?
    if ($wasscreened and $parent->{state} ne 'S') {
        $ret .= "<?p $ML{'.success.unscreened'} p?>";
    }

    if ($init->{didlogin}) {
        $ret .= "<?p $ML{'.success.loggedin'} p?>";
    }

    return $ret;
}
_code?>

<=body
head<=
<?_code return (! $LJ::REQ_HEAD_HAS{'chalresp_js'}++) ? $LJ::COMMON_CODE{'chalresp_js'} : ""; _code?>
<=head
page?><?_c <LJDEP>
lib: LJ::SpellCheck
link: htdocs/lostinfo.bml, htdocs/userinfo.bml, htdocs/talkread.bml, htdocs/editinfo.bml
post: htdocs/talkpost_do.bml
</LJDEP> _c?>
