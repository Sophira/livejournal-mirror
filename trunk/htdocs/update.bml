<?_code
#BML:cache:update
{
    use strict;
    use vars qw(%GET %POST %ML);

    # $_[1] is a pre-request scratch area
    # put variables here so that we can access them later
    # outside of this _code block
    my $title = \$_[1]->{'title'};
    my $head = \$_[1]->{'head'};
    my $body = \$_[1]->{'body'};
    my $bodyopts = \$_[1]->{'bodyopts'};

    # set page title
    $$title = $ML{'.title'};

    # server down?
    if ($LJ::SERVER_DOWN) {
        $$body = LJ::server_down_html();
        return;
    }

    # invalid text input?
    unless (LJ::text_in(\%POST)) {
        $$body = "<?badinput?>";
        return;
    }

    # get remote and see if they can post right now
    my $remote = LJ::get_remote();
    if ($remote) {
        if (LJ::get_cap($remote, "readonly") ||
            ! LJ::get_cluster_master($remote)) {

            $$title = $ML{'.title.readonly'};
            $$body = $LJ::MSG_READONLY_USER;
            return;
        }

        if (! LJ::get_cap($remote, "can_post")) {
            $$title = "Can't Post";
            $$body = $LJ::MSG_NO_POST || "Sorry, you cannot post at this time.";
            return;
        }

        if (LJ::get_cap($remote, "disable_can_post")) {
            unless (LJ::run_hook("update.bml_disable_can_post", {
                title => $title, body => $body,
            })) {
                $$title = "Posting access disabled";
                $$body = "Your account type does not permit posting.";
            }
            return;
        }
    }

    # are we spellchecking before we post?
    my $spellcheck_html;
    my $did_spellcheck;
    if ($LJ::SPELLER && $POST{'do_spellcheck'}) {
        my $s = new LJ::SpellCheck { 'spellcommand' => $LJ::SPELLER,
                                     'color' => '<?hotcolor?>', };
        my $event = LJ::ehtml($POST{'event'});
        $spellcheck_html = $s->check_html(\$event);
        $did_spellcheck++;
    }

    ### define some bools with common logic ###
    my $did_post = LJ::did_post();
    my $user_is_remote = $remote && $remote->{'user'} eq $POST{'user'};           # user is remote
    my $auth_as_remote = $remote && (! $GET{'altlogin'} || $user_is_remote);      # auth as remote
    my $auth_missing = $POST{'user'} && ! $POST{'password'} && ! $user_is_remote; # user w/o password
    my $showform = $POST{'showform'} || $auth_missing;                            # show entry form
    my $mode = $GET{'mode'};
    $mode = 'full' if $GET{'usejournal'} || $POST{'usejournal_set'};

    # richtext
    # 'switched_rte_on' is only set when the user first enables rte.  We do this in a POST
    #    so any pre-existing text in the event and subject fields aren't lost when going to RTE.
    # 'rich' is used to keep RTE mode enabled between pages, such as spellchecks.
    # The $GET{'rich'} is simply for user bookmarking / faq linking convenience.
    my $enabled_rte = $POST{'switched_rte_on'};
    my $richtext = 1 if $GET{rich} || $POST{rich} ||
                        ($enabled_rte && ! $spellcheck_html);
    $$bodyopts = "onunload=\"save_entry();\" " if $richtext;

    if ($did_post && ! $spellcheck_html && ! $showform && ! $enabled_rte) {

        # what's our authentication scheme for subsequent protocol actions?
        my $flags = {};
        my $user;

        if ($POST{'user'} &&                            # user argument given
            ! $user_is_remote &&                        # user != remote 
            (!$remote || $GET{'altlogin'})) {           # user has clicked alt auth
            
            $user = $POST{'user'};

        } elsif ($remote) {                             # assume remote if we have it
            $flags = { 'noauth' => 1, 'u' => $remote };
            $user = $remote->{'user'};
        }
       
        # do a login action
        my $login_message;
        {
            # build a clientversion string
            my $clientversion = $POST{'webversion'} eq 'full' ? "Web/1.1" : "Web/1.0";
            $clientversion .= 's' if $did_spellcheck;

            # build a request object
            my %req = ( 'mode' => 'login',
                        'ver' => $LJ::PROTOCOL_VER,
                        'clientversion' => $clientversion,
                        'user' => $user,
                        'password' => $POST{'password'},
                        'hpassword' => $POST{'hpassword'},
                       );

            my %res;
            LJ::do_request(\%req, \%res, $flags);

            # error logging in ?
            unless ($res{'success'} eq 'OK') {
                $$body .= "<?h1 $ML{'.loggingin'} h1?>\n";
                $$body .= "<?p $ML{'.error.login'} <ul><li><b>" . LJ::ehtml($res{'errmsg'}) . "</b></li></ul> p?>";
                return;
            }

            # server login message for user?
            $login_message = LJ::auto_linkify(LJ::ehtml($res{'message'}))
                if $res{'message'};
        }

        # do update postevent
        {
            # find security
            my $sec = "public";
            my $amask = 0;
            if ($POST{'security'} eq "private") { $sec = "private"; }
            elsif ($POST{'security'} eq "friends") { $sec = "usemask"; $amask = 1; }
            elsif ($POST{'security'} eq "custom") {
                $sec = "usemask";
                foreach my $bit (1..30) {
                    next unless $POST{"custom_bit_$bit"};
                    $amask |= (1 << $bit);
                }
            }
     
            # next, postevent
            my %req = ( 'mode' => 'postevent',
                        'ver' => $LJ::PROTOCOL_VER,
                        'user' => $user,
                        'password' => $POST{'password'},
                        'hpassword' => $POST{'hpassword'},
                        'usejournal' => $POST{'usejournal'},
                        'security' => $sec,
                        'allowmask' => $amask,
                        );

            # copy some things from %POST
            foreach (qw(subject year mon day hour min
                        prop_picture_keyword prop_current_moodid
                        prop_current_mood prop_current_music)) {
                $req{$_} = $POST{$_};
            }

            # Convert the rich text editor output back to parsable lj tags.
            my $event = $POST{event};
            if ($richtext) {
                $event =~ s/&lt;(\/)?lj-cut(.*?)(?: \/)?&gt;/<$1lj-cut$2>/ig;
                $event =~ s/&lt;lj user=['"]?(\w{1,15})['"]?\s?\/?&gt;/<lj user="$1" \/>/ig; # manually typed tags
                $event =~ s/<span class="?ljuser"?.*?userinfo\.bml\?user=(.+?)".*?<\/b><\/a>(?:<\/span>)?/<lj user="$1" \/>/ig;
            }
            $req{'event'} = $event;

            # copy some opts, but make sure they are 1 : 0 explicitly
            foreach (qw(preformatted nocomments backdated noemail)) {
                $req{"prop_opt_$_"} = $POST{"prop_opt_$_"} ? 1 : 0;
            }

            ## see if an "other" mood they typed in has an equivalent moodid
            if ($POST{'prop_current_mood'}) {
                if (my $id = LJ::mood_id($POST{'prop_current_mood'})) {
                    $req{'prop_current_moodid'} = $id;
                    delete $req{'prop_current_mood'};
                }
            }

            my %res;
            LJ::do_request(\%req, \%res, $flags);

            # examine response
            my $update_message;
            if ($res{'success'} eq "OK" && $res{'message'}) {
                $update_message = LJ::auto_linkify(LJ::ehtml($res{'message'}));
            }
     
            # report results
            $$body .= "<?h1 $ML{'.updating'} h1?>\n";

            # update failed?
            unless ($res{'success'} eq 'OK') {
                $$body .= "<?p $ML{'.error.update'} <ul><li><b>" . LJ::ehtml($res{'errmsg'}) . "</b></li></ul> p?>";
                return;
            }

            # update success
            my $ju;
            if ($POST{'usejournal'}) {
                $ju = LJ::load_user($POST{'usejournal'});  # posting as community
            } elsif ($user) {
                $ju = LJ::load_user($user);                # posting not as user from form
            } else {
                $ju = $remote;                             # posting as remote
            };
            $$body .= "<?p ".BML::ml(".update.success", { 'uri' => LJ::journal_base($ju) . "/" }) ." p?>";

            # any messages from the server?
            if ($login_message) {
                $$body .= "<?h1 $ML{'.loggingin'} h1?>\n";
                $$body .= "<?p $ML{'.servermsg'} p?><div style='margin-left: 40px'><b>$login_message</b></div>";
            }
            if ($update_message) {
                $$body .= "<?h1 $ML{'.update.head'} h1?>\n";
                $$body .= "<?p $ML{'.updmsg'} p?><div style='margin-left: 40px'><b>$update_message</b></div>";
            }
        }
        
        return;
    }

    ###
    ### show update form
    ###

    $$body .= "<?h1 $ML{'.update.head'} h1?><?p $ML{'.update.about'} p?><?hr?>";

    {
        # if they submit the form and are spellchecking, remember
        # their settings from the GET requests
        my $getextra;
        $getextra .= "altlogin=1&" if $GET{'altlogin'};
        $getextra .= "mode=full&" if $mode eq 'full';
        $getextra .= "rich=1&" if $richtext;
        chop $getextra;
        $getextra = "?$getextra" if $getextra;

        $$body .= "<div style='width: 90%'><form method='post' action='update.bml$getextra' name='updateForm'>";
    }

    $$body .= "<table align='center' width='80%'>\n<tr><td width='50%'>\n";

    {
        # which authentication option do we display by default?
        my $altlogin_display = 'none';
        my $remotelogin_display = 'none';
        if ($auth_as_remote) {
            $remotelogin_display = 'inline';
        } else {
            $altlogin_display = 'block';
        }

        my $altget = $mode eq 'full' ? "?mode=full&altlogin=1" : "?altlogin=1";
        $$body .= "<p id='remotelogin' style='display: $remotelogin_display;'>";
        if ($remote) { # so lynx won't show this
            $$body .= "You are currently logged in as <b>$remote->{'user'}</b>.";
            $$body .= "<br />To post as another user, <a href='update.bml$altget'>click here</a>.";
        }
        $$body .= "</p>\n";

        # table with username/password fields
        $$body .= "<table id='altlogin' style='display: $altlogin_display;'>\n";
        $$body .= "<tr valign='top'><td align='right'>Username:</td>";
        $$body .= "<td align='left'>";
        $$body .= LJ::html_text({ 'name' => 'user', 'size' => '15', 'maxlength' => '15',
                                  'value' => $POST{'user'} || $GET{'user'} });
        $$body .= "</td></tr>\n";
        $$body .= "<tr valign='top'><td align='right'>Password:</td>";
        $$body .= "<td align='left'>";
        $$body .= LJ::html_text({ 'type' => 'password', 'name' => 'password',
                                  'size' => '15', 'maxlength' => '30' });

        # posted with a user, but no password
        if ($did_post && $auth_missing) {
            $$body .= "<br /><?inerr Enter Password inerr?>";
        }
        $$body .= "</td></tr>\n";
        $$body .= "</table>\n";
    }

    $$body .= "</td><td>\n";
    
    $$body .= "<table cellspacing='0' cellpadding='0'>\n";
  
    my ($min,$hour,$mday,$mon,$year);

    # preserve times from form if spellchecking
    if ($did_spellcheck) {
        $$bodyopts .= "onload=\"pageload(0);\" "; # js fill-in off

        $year = $POST{'year'};
        $mon = $POST{'mon'};
        $mday = $POST{'day'};
        $hour = $POST{'hour'};
        $min = $POST{'min'};
        
    # insert current time
    } else {
        $$bodyopts .= "onload=\"pageload(1);\" "; # js fill-in on

        my @time = localtime(time);
        $year = $time[5] + 1900;
        $mon = sprintf("%02d", $time[4] + 1);
        $mday = sprintf("%02d", $time[3]);
        $hour = $time[2];
        $min = sprintf("%02d", $time[1]);
    }

    # date entry boxes / formatting note
    $$body .= "<tr valign='top'><td align='right' rowspan='2'><b>$ML{'.date'}</b>&nbsp;</td><td nowrap='nowrap'>";
    $$body .= LJ::html_text({ 'name' => 'year', 'value' => $year, 'size' => '5', 'maxlength' => '4' }) . '-';
    $$body .= LJ::html_text({ 'name' => 'mon',  'value' => $mon,  'size' => '3', 'maxlength' => '2' }) . '-';
    $$body .= LJ::html_text({ 'name' => 'day',  'value' => $mday, 'size' => '3', 'maxlength' => '2' });
    $$body .= "</td></tr>\n";
    $$body .= "<tr valign='top'><td><i>(yyyy-mm-dd)</i></td></tr>\n";

    # time entry boxes / formatting note
    $$body .= "<tr valign='top'><td align='right' rowspan='2'><b>$ML{'.localtime'}</b>&nbsp;</td><td>";
    $$body .= LJ::html_text({ 'name' => 'hour', 'value' => $hour, 'size' => '3', 'maxlength' => '2' }) . ':';
    $$body .= LJ::html_text({ 'name' => 'min',  'value' => $min,  'size' => '3', 'maxlength' => '2' });
    $$body .= "</td></tr>\n";
    $$body .= "<tr valign='top'><td><i>($ML{'.timeformat'})</i></td></tr>\n";
    $$body .= "</table>\n</td></tr>\n";

    $$body .= "</table>\n";

    # if no script, above is server time
    $$body .= "<noscript><p align='center' style=\"font-size: 0.85em;\">$ML{'.note'}</p></noscript>\n";

    # subject
    $$body .= "<table width='90%' align='center'; style='margin-top: 20px;'><tr><td>$ML{'.subject'}<br />";
    $$body .= LJ::html_text({ 'name' => 'subject', 'value' => $POST{subject} || $GET{subject},
                              'size' => '50', 'maxlength' => '100' }) . "\n";

    # display spell check results
    $$body .= "<p><b>$ML{'.spellchecked'}</b><br />$spellcheck_html</p>"
        if $spellcheck_html;

    # event
    $$body .= "<p><b>$ML{'.event'}</b>";
    $$body .= "<br />";
    if ($richtext) {
        my $jevent = $POST{event} || $GET{event};

        # manually typed tags
        $jevent =~ s/<lj user=['"]?(\w{1,15})['"]?\s?\/?>/&lt;lj user="$1" \/&gt;/ig;
        $jevent =~ s/<(\/)?lj-cut(.*?)(?: \/)?>/&lt;$1lj-cut$2&gt;/ig;

        $jevent = LJ::ejs($jevent);
        my $rte_nosupport = LJ::ejs(BML::fill_template("de", { DATA => $ML{'.htmlokay.rte_nosupport'} }));

        $$body .= LJ::html_hidden('rich', '1') . "\n";
        $$body .= LJ::html_hidden('saved_entry', '') . "\n";

        $$body .= <<RTE;
<iframe id="testFrame" style="position: absolute; visibility: hidden; width: 0px; height: 0px;"></iframe>
<script language="JavaScript" type="text/javascript" src="/js/browserdetect.js"></script>
<script language='JavaScript' type='text/javascript'>
    <!--
        var siteroot = "$LJ::SITEROOT";
    //-->
</script>
<script language="JavaScript" type="text/javascript" src="/js/richtext.js"></script>
<script language='JavaScript' type='text/javascript'>
    <!--
        writeRichText('rte', 'event', '$jevent', '95%', 300, true);
        if (isRichText == false) {
            document.write("$rte_nosupport");
        }
    //-->
</script>
<noscript>
RTE
    }
    $$body .= LJ::html_textarea({ 'name' => 'event', 'value' => $POST{event} || $GET{event},
        'rows' => '20', 'cols' => '50', 'style' => 'width: 100%', 'wrap' => 'soft' });
    $$body .= '</noscript>' if $richtext;

    my $jrich = LJ::ejs(BML::fill_template("de", {
        DATA => BML::ml(".htmlokay.rich", { 'opts' => 'href="#" onClick="enable_rte()"' })
        }));
    my $jnorich = LJ::ejs(BML::fill_template("de", { DATA => $ML{'.htmlokay.norich'} }));

    unless ($richtext || ($POST{do_spellcheck} && $richtext)) {
        $$body .= <<RTE;
<script language='JavaScript' type='text/javascript'>
    <!--
        var t = document.getElementById;
        if (t) {
            document.write('<input type="hidden" name="switched_rte_on" value="" />');
            document.write("$jrich");
        } else {
            document.write("$jnorich");
        }
    //-->
</script>
RTE
        $$body .= '<noscript><?de ' . $ML{'.htmlokay.norich'} . ' de?></noscript>';
    }
    $$body .= '<br />';

    # spell check checkbox
    if ($LJ::SPELLER) {
        $$body .= "<br />" . LJ::html_check({ 'name' => 'do_spellcheck', 'id' => 'do_spellcheck' });
        $$body .= "<label for='do_spellcheck'>$ML{'.opt.spellcheck'}</label>";
    }
    $$body .= "</p></td></tr><tr><td>";

    {
        # simple mode block
        my $simple_display = $mode eq 'full' ? 'none' : 'block';
        $$body .= "<div id='simplemsg' style='margin-top: 10px; display: $simple_display;'>";
        my $fullget = $GET{'altlogin'} ? "?altlogin=1&mode=full" : "?mode=full";
        $$body .= BML::ml(".simple", {'url' => "update.bml$fullget" }) ."</p>";
        $$body .= "</div>";

        # put alternate link in head if not already viewing full mode
        $$head .= "<link href='update.bml$fullget' rel='alternate' title='$ML{'.full'}' />\n"
            unless $mode eq 'full';
    }

    {
        # full mode block
        my $full_display = $mode eq 'full' ? 'block' : 'none';
        $$body .= "<div id='fullopts' style='display: $full_display;'>";
    }

    $$body .= "<table>\n<tr><td nowrap='nowrap'>\n";
    $$body .= "<?h2 $ML{'.options'} h2?>\n";

    $$body .= LJ::html_hidden('webversion', 'full') . "\n";

    # do a login action to get pics and usejournals, but only if using remote
    my $res;
    if ($auth_as_remote) {

        $res = LJ::Protocol::do_request("login", {
            "ver" => $LJ::PROTOCOL_VER,
            "username" => $remote->{'user'},
            "getpickws" => 1,
        }, undef, { 
            "noauth" => 1, 
            "u" => $remote,
        });
    }

    # communities the user can post in
    my $usejournal = $POST{usejournal} || $GET{usejournal};
    if ($GET{usejournal} || $POST{usejournal_set}) {
        $$body .= "<b>$ML{'.altpost'}</b> ";
        $$body .= LJ::ljuser($usejournal);
        $$body .= LJ::html_hidden('usejournal' => $usejournal, 'usejournal_set' => 'true');
    } elsif ($res && ref $res->{'usejournals'} eq 'ARRAY') {
        $$body .= "<p id='usejournal_list' style='display: block;'><b>$ML{'.altpost'} </b> ";
        $$body .= LJ::html_select({ 'name' => 'usejournal',
                                    'selected' => $POST{'usejournal'} },
                                    "", BML::ml(".defaultjournal", { 'user' => $remote->{'user'} }),
                                    map { $_, $_ } @{$res->{'usejournals'}}) . "</p>\n";
    }
    
    # possible security groups
    $$body .= "<p><b>$ML{'label.security.head'}</b> ";
    my @secs = ("public", $ML{'label.security.public'}, "private", $ML{'label.security.private'},
                "friends", $ML{'label.security.friends'});
    
    my @opts;
    if ($res && ref $res->{'friendgroups'} eq 'ARRAY') {
        push @secs, ("custom", $ML{'label.security.custom'});
        push @opts, ("onchange" => "customboxes()");
    }

    $$body .= LJ::html_select({ 'name' => 'security', 'selected' => $POST{'security'}, @opts }, @secs);
    $$body .= LJ::help_icon("security", " ");
     
    # if custom security groups available, show them in a hidable div
    if ($res && ref $res->{'friendgroups'} eq 'ARRAY') {
        my $display = $POST{'security'} eq "custom" ? "block" : "none";
        $$body .= "<div id='custom_boxes' style='display: $display;'>";
        foreach my $fg (@{$res->{'friendgroups'}}) {
            $$body .= LJ::html_check({ 'name' => "custom_bit_$fg->{'id'}",
                                       'id' => "custom_bit_$fg->{'id'}",
                                       'selected' => $POST{"custom_bit_$fg->{'id'}"} });

            $$body .= "<label for='custom_bit_$fg->{'id'}'>" . LJ::ehtml($fg->{'name'}) . "</label><br />";
        }
        $$body .= "</div>";
    }
    $$body .= "\n";

    ### opt_ checkboxes
    my $prop_check = sub {
        my $prop = shift;
        my $prop_ml = shift || $prop;

        return "<b><label for='prop_opt_$prop'>" . $ML{".opt.$prop_ml"} . "</label></b> " .
            LJ::html_check({ 'type' => 'check',
                             'name' => "prop_opt_$prop",
                             'id' => "prop_opt_$prop",
                             'selected' => $POST{"prop_opt_$prop"} });
    };

    # backdating
    $$body .= "<p>" . $prop_check->('backdated', 'backdate') . " ";

    # don't auto-format
    if ($richtext) {
        $$body .= LJ::html_hidden('prop_opt_preformatted', '1') . "\n";
    } else {
        $$body .= $prop_check->('preformatted', 'noformat') . LJ::help_icon("noautoformat", " ") . "</p>\n";
    }

    # don't allow comments
    $$body .= "<p>" . $prop_check->('nocomments') . " ";

    # don't email the poster
    $$body .= $prop_check->('noemail') . "\n";
     
    # picture to use
    if ($res && ref $res->{'pickws'} eq 'ARRAY') {
        $$body .= "<p id='userpic_list' style='display: block'>";
        $$body .= "<b>".BML::ml(".picture", {'url' => "$LJ::SITEROOT/allpics.bml?user=$remote->{'user'}"})."</b> ";
        $$body .= LJ::html_select({'name' => 'prop_picture_keyword', 
                                   'selected' => $POST{'prop_picture_keyword'} },
                                  "", $ML{'.opt.defpic'},
                                  map { ($_, $_) } sort { lc($a) cmp lc($b) } @{$res->{'pickws'}});
        $$body .= LJ::help_icon("userpics", " ") . "</p>\n";
    }

    # mood
    {
        my @moodlist = ('', $ML{'.noneother'});
        my $sel;

        my $moods = LJ::get_moods();

        foreach (sort { $moods->{$a}->{'name'} cmp $moods->{$b}->{'name'} } keys %$moods) {
            push @moodlist, ($_, $moods->{$_}->{'name'});

            if ($POST{'prop_current_mood'} eq $moods->{$_}->{'name'} ||
                $POST{'prop_current_moodid'} == $_) {
                $sel = $_;
            }
        }

        $$body .= "<p><b>$ML{'.currmood'}</b>";
        $$body .= LJ::html_select({ 'name' => 'prop_current_moodid',
                                  'selected' => $sel }, @moodlist);
        $$body .= " $ML{'.other'} " . LJ::html_text({ 'name' => 'prop_current_mood',
                                                      'value' => $POST{'prop_current_mood'},
                                                      'size' => '15', 'maxlength' => '30' }) . "\n";
    }
    
    # current music
    $$body .= "<p><b>$ML{'.currmusic'}</b> ";
    $$body .= LJ::html_text({ 'name' => 'prop_current_music', 'value' => $POST{'prop_current_music'},
                              'size' => '40', 'maxlength' => '60' }) . "</p>\n";
    $$body  .= "</td></tr>\n";

    # end full opts block
    $$body .= "</table>";
    $$body .= "</div></td></tr>\n";

    $$body .= "</table>\n";

    # submit button
    $$body .= "<p align='center' style='margin-top: 0px;'>";
    $$body .= "<input type='submit' value='$ML{'.btn.update'}' ";
    $$body .= "onClick=\"updateRTE('rte')\"" if $richtext;
    $$body .= "></p>\n";

    $$body .= "</form></div>";

    return;
}

_code?><?page
title=><?_code return $_[1]->{'title'}; _code?>
body=><?_code return $_[1]->{'body'}; _code?>
bodyopts=><?_code return $_[1]->{'bodyopts'}; _code?>
head<=
<?_code return $_[1]->{'head'}; _code?>
<script language="JavaScript"><!--

    function settime() {
        function twodigit (n) {
            if (n < 10) { return "0" + n; }
            else { return n; }
        }

        now = new Date();
        if (! now) return false;
        f = document.updateForm;
        if (! f) return false;

        f.year.value = now.getYear() < 1900 ? now.getYear() + 1900 : now.getYear();
        f.mon.value = twodigit(now.getMonth()+1);
        f.day.value = twodigit(now.getDate());
        f.hour.value = twodigit(now.getHours());
        f.min.value = twodigit(now.getMinutes());

        return false;
    }

    function showfull (e) {
        if (! e) var e = window.event;
        if (! document.getElementById) return false;

        var fullopts = document.getElementById('fullopts');
        if (! fullopts) return false;
        fullopts.style.display = 'block';

        var simplemsg = document.getElementById('simplemsg');
        if (! simplemsg) return false;
        simplemsg.style.display = 'none';

        f = document.updateForm;
        if (! f) return false;
        f.action = 'update.bml?mode=full';

        var altlogin = document.getElementById('altlogin');
        if (! altlogin) return false;
        if (altlogin.style.display == 'inline')
            f.action += '&altlogin=1'

        if (e) {
            e.cancelBubble = true;
            if (e.stopPropagation) e.stopPropagation();
        }
        return false;
    }

    function altlogin (e) {
        if (! e) var e = window.event;
        if (! document.getElementById) return false;

        var altlogin = document.getElementById('altlogin');
        if (! altlogin) return false;
        altlogin.style.display = 'inline';

        var remotelogin = document.getElementById('remotelogin');
        if (! remotelogin) return false;
        remotelogin.style.display = 'none';

        var usejournal_list = document.getElementById('usejournal_list');
        if (! usejournal_list) return false;
        usejournal_list.style.display = 'none';

        var userpic_list = document.getElementById('userpic_list');
        if (! userpic_list) return false;
        userpic_list.style.display = 'none';

        f = document.updateForm;
        if (! f) return false;
        f.action = 'update.bml?altlogin=1';

        var custom_boxes = document.getElementById('custom_boxes');
        if (! custom_boxes) return false;
        custom_boxes.style.display = 'none';
        f.security.selectedIndex = 0;

        var fullopts = document.getElementById('fullopts' );
        if (! fullopts) return false;
        if (fullopts.style.display == 'block')
            f.action += '&mode=full'

        if (e) {
            e.cancelBubble = true;
            if (e.stopPropagation) e.stopPropagation();
        }
        return false;
    }

    function customboxes (e) {
        if (! e) var e = window.event;
        if (! document.getElementById) return false;

        f = document.updateForm;
        if (! f) return false;

        var altlogin = document.getElementById('altlogin');
        if (! altlogin) return false;

        var custom_boxes = document.getElementById('custom_boxes');
        if (! custom_boxes) return false;

        if (f.security.selectedIndex != 3) {
            custom_boxes.style.display = 'none';
            return false;
        }

        if (altlogin.style.display == 'inline') {
            f.security.selectedIndex = 0;
            custom_boxes.style.display = 'none';
            alert("Custom security is only available when posting as the logged in user.");
        } else {
            custom_boxes.style.display = 'block';
        }

        if (e) {
            e.cancelBubble = true;
            if (e.stopPropagation) e.stopPropagation();
        }
        return false;
    }

    function pageload (dotime) {
        restore_entry();
        if (dotime) settime();
        if (!document.getElementById) return false;
        var remotelogin = document.getElementById('remotelogin');
        if (! remotelogin) return false;
        remotelogin.onclick = altlogin;
        f = document.updateForm;
        if (! f) return false;
        var userbox = f.user;
        if (! userbox) return false;
        if (userbox.value) altlogin();
        var simplemsg = document.getElementById('simplemsg');
        if (! simplemsg) return false;
        simplemsg.onclick = showfull;

        // force full mode if any values are not defaults
        if (f.usejournal && f.usejournal.value ||
            f.prop_picture_keyword && f.prop_picture_keyword.value ||
            f.security.value != 'public' ||
            f.prop_opt_backdated.checked ||
            f.prop_opt_preformatted.checked ||
            f.prop_opt_nocomments.checked ||
            f.prop_opt_noemail.checked ||
            f.prop_current_moodid.value ||
            f.prop_current_mood.value ||
            f.prop_current_music.value) showfull();

        return false;
    }

    function enable_rte () {
        if (! document.getElementById) return false;

        f = document.updateForm;
        if (! f) return false;
        f.switched_rte_on.value = 1;
        f.submit();
        return false;
    }

    // Maintain entry through browser navigations.
    // IE does this onBlur, Gecko onUnload.
    function save_entry () {
        if (! document.getElementById) return false;

        f = document.updateForm;
        if (! f) return false;
        rte = document.getElementById('rte');
        if (! rte) return false;
        content = document.getElementById('rte').contentWindow.document.body.innerHTML;
        f.saved_entry.value = content;
        return false;
    }

    // Restore saved_entry text across platforms.
    // This is only used for IE, Gecko browser support is in the RTE library.
    function restore_entry () {
        if (! document.getElementById) return false;
        f = document.updateForm;
        if (! f) return false;
        rte = document.getElementById('rte');
        if (! rte) return false;
        if (document.updateForm.saved_entry.value == "") return false;
        setTimeout(
            function () {
                document.getElementById('rte').contentWindow.document.body.innerHTML = 
                    document.updateForm.saved_entry.value;
            }, 100);
        return false;
    }

// -->
</script>

<=head
page?><?_c <LJDEP>
lib: LJ::SpellCheck
link: htdocs/users, htdocs/download/index.bml, htdocs/moodlist.bml
link: htdocs/update.bml, htdocs/lostinfo.bml, htdocs/support/faqbrowse.bml
link: htdocs/allpics.bml
post: htdocs/update.bml
</LJDEP> _c?>
