<?page
title=><?_ml .title _ml?>
body<=

<?_code

 return LJ::server_down_html() if ($LJ::SERVER_DOWN);
 return "<?badinput?>" unless LJ::text_in(\%FORM);

 my @errors = ();
 my $user = LJ::canonical_username($FORM{'user'});
 my $hpassword = $FORM{'hpassword'} || LJ::hash_password($FORM{'password'});

 my $dbs = LJ::get_dbs();
 my $dbh = $dbs->{'dbh'};
 my $dbr = $dbs->{'reader'};

 return BML::redirect("/modify.bml") unless $user ne "";

my $u;
my $as_remote = 0;
if ($FORM{'remoteuser'} eq $user) {
    $u = LJ::get_remote($dbs);
    $as_remote = 1;
} else {
    $u = LJ::load_user($dbs, $user);
}
 unless ($u) { push @errors, $ML{'error.username_notfound'}; }

 $user = $u->{'user'};
 my $quser = $dbh->quote($user);

 my $capstyles = LJ::get_cap($u, "styles");

 LJ::load_user_props($dbs, $u, "opt_usesharedpic",
                     "s1_lastn_style", "s1_calendar_style",
                     "s1_day_style", "s1_friends_style",
                     "stylesys",
                     "journaldomain",
                     );

 my $ipbanned = 0;
 if (! $as_remote && 
     scalar(@errors)==0 && 
     ! LJ::auth_okay($u, $FORM{'password'}, $FORM{'hpassword'}, undef, \$ipbanned)) { 
     if ($ipbanned) {
         push @errors, "$ML{'error.ipbanned'}"; 
     } else {
         push @errors, "$ML{'error.badpassword'}"; 
     }
 }

 return LJ::bad_input(@errors) if @errors;

 my %countries;
 my %states;
 LJ::load_codes($dbs, { "country" => \%countries, "state" => \%states });

 my $mode = $FORM{'mode'} || "modify";
 my $and;

 if ($mode eq "modify")
 {
     return "Post required." unless LJ::did_post();
     my $ret = "";
     $ret .= "<form method='post' action='modify_do.bml'>\n";
     $ret .= LJ::html_hidden("mode", "domodify",
                             "user", $user);
     if ($as_remote){
         $ret .= LJ::html_hidden("remoteuser", $u->{'user'});
     } else {
         $ret .= LJ::html_hidden("hpassword", $hpassword);
     }

     ### journal style
     $ret .= "<?h1 $ML{'.journaloptions.head'} h1?><?p $ML{'.journaloptions.about'} p?>\n";

     ###
     ### LAYOUT OPTIONS
     ###

     unless ($u->{'stylesys'} == 2) 
     {
         $and = $capstyles ? "" : "<?_ml .pagelayoutstyle.warning _ml?>";
         $ret .= "<?h2 $ML{'.pagelayoutstyle.head'} h2?><?p $ML{'.pagelayoutstyle.about'}  $and p?><UL><TABLE><TR BGCOLOR=#D0D0D0><TD></TD><TD>$ML{'.availablestyles.head'}</TD></TR>\n";
         my %styles = ();
         
         $sth = $dbr->prepare("SELECT styleid, styledes, user, type ".
                              "FROM style WHERE (user='system' AND is_public='Y') ".
                              "OR user=$quser ORDER BY styledes");
         $sth->execute;
         push @{$styles{$_->{'type'}}}, $_ while ($_ = $sth->fetchrow_hashref);
         
         foreach my $view (@LJ::views)
         {
             $ret .= "<TR><TD BGCOLOR=#D0D0D0>$LJ::viewinfo{$view}->{'des'}</TD><TD><SELECT NAME=\"s1_${view}_style\">\n";
             foreach (grep { $_->{'user'} eq "system" } @{$styles{$view}})
             {
                 my $selected = $_->{'styleid'}==$u->{"s1_${view}_style"} ? " SELECTED" : "";
                 $ret .= "<OPTION VALUE=\"$_->{'styleid'}\"$selected>" . BML::eall($_->{'styledes'}) . "\n";
             }
             my $exist_user_style = 0;
             foreach (grep { $_->{'user'} ne "system" } @{$styles{$view}})
             {
                 if (!$exist_user_style)
                 {
                     $exist_user_style = 1;
                     $ret .= "<OPTION VALUE=\"\">--- $ML{'.availablestyles.userstyles'} ---\n";
                 }
                 my $selected = $_->{'styleid'}==$u->{"s1_${view}_style"} ? " SELECTED" : "";
                 $ret .= "<OPTION VALUE=\"$_->{'styleid'}\"$selected>" . BML::eall($_->{'styledes'}) . "\n";
             }
             $ret .= "</SELECT></TD></TR>\n";
         }
         $ret .= "</TABLE></UL>\n";
         
         ###
         ### COLOR THEME OPTIONS
         ###
         $ret .= "<?h2 $ML{'.colortheme.head'} h2?><?p $ML{'.colortheme.about'} p?>\n";
         $ret .= "<div style='margin-left: 30px'>\n";
         $checked = $u->{'themeid'} != 0 ? "checked='checked'" : "";
         $ret .= "<input type='radio' value=\"default\" name='themetype' $checked> <b>$ML{'.colortheme.defaulttheme'}</b>: ";
         $ret .= "<select name='themeid'>\n";
         $sth = $dbr->prepare("SELECT themeid, name FROM themelist ORDER BY name");
         $sth->execute;
         while ($_ = $sth->fetchrow_hashref) {
             $checked = $u->{'themeid'} == $_->{'themeid'} ? "selected='selected'" : "";
             $ret .= "  <option value='$_->{'themeid'}' $checked>$_->{'name'}</option>\n";
         }
         $ret .= "</select><br />\n";
         $checked = $u->{'themeid'} == 0 ? "checked='checked'" : "";
         $ret .= "<input type='radio' value=\"custom\" name='themetype' $checked> <b>$ML{'.colortheme.customcolors'}</b>:";
         $ret .= "<center><table border='1' cellpadding='2'>\n";
         $ret .= "<tr valign='top' bgcolor='#D0D0D0'><td align='right'><b>$ML{'.colortheme.area.head'}</b></td><td><b>$ML{'.colortheme.color.head1'}</b><br /><font size='-1'>$ML{'.colortheme.color.head2'}</font></td></tr>\n";
         
         # get the user's custom colors
         my %custcolors = ();

         if ($u->{'themeid'} == 0) {
             my $dbcr = LJ::get_cluster_reader($u);
             my $stor = $dbcr->selectrow_array("SELECT color_stor FROM s1usercache WHERE userid=?", undef, $u->{'userid'});
             if ($stor) {
                 %custcolors = %{ Storable::thaw($stor) };
             } else {
                 # ancient table.
                 $sth = $dbr->prepare("SELECT coltype, color FROM themecustom WHERE user=?");
                 $sth->execute($u->{'user'});
                 $custcolors{$_->{'coltype'}} = $_->{'color'} while $_ = $sth->fetchrow_hashref;
             }
         } else {
             my $qthemeid = $dbr->quote($u->{'themeid'});
             $sth = $dbr->prepare("SELECT coltype, color FROM themedata WHERE themeid=$qthemeid");
             $sth->execute;
             $custcolors{$_->{'coltype'}} = $_->{'color'} while $_ = $sth->fetchrow_hashref;
         }
         
         my $dig;
         foreach my $col (@LJ::S1::themecoltypes) {
             $ret .= "<tr><td align='right'>$col->[1]</td><td><input type='text' name=\"theme_cust:$col->[0]\" size='20' maxlength='30' value=\"" . LJ::ehtml($custcolors{$col->[0]}) . "\"></td></tr>\n";
             $dig .= $col->[0];
         }
         $dig = Digest::MD5::md5_hex($dig);
         $ret .= LJ::html_hidden("themecolors_dig", $dig) unless $u->{'themeid'};
         
         $ret .= "</table></center>\n";
         $ret .= "</div>\n";
     }

     ###
     ### MOOD THEME OPTIONS
     ###
     $ret .= "<?h2 $ML{'.moodicons.head'} h2?><?p $ML{'.moodicons.about'} p?>";

     $sth = $dbr->prepare("SELECT moodthemeid, name FROM moodthemes WHERE is_public='Y'");
     $sth->execute;
     my @themes = ({ 'moodthemeid' => 0, 'name' => '(None)' });
     push @themes, $_ while ($_ = $sth->fetchrow_hashref);

     ### user's private themes
     {	
         my @theme_user;
         $sth = $dbr->prepare("SELECT moodthemeid, name FROM moodthemes WHERE ownerid=$u->{'userid'} AND is_public='N'");
         $sth->execute;
         push @theme_user, $_ while ($_ = $sth->fetchrow_hashref);
         if (@theme_user) {
             push @themes, { 'moodthemeid' => 0, 'name' => "--- $ML{'.moodicons.personal'} ---" };
             push @themes, @theme_user;
         }
     }

     $ret .= "<div style='margin-left: 30px'><b>$ML{'.moodicons.select'} </b> <select name=\"moodthemeid\">";
     foreach my $t (@themes) {
         my $sel = $t->{'moodthemeid'} == $u->{'moodthemeid'} ? "SELECTED" : "";
         $ret .= "<OPTION $sel VALUE=$t->{'moodthemeid'}>" . LJ::ehtml($t->{'name'}) . "\n";
     }
     $ret .= "</SELECT> (<A HREF=\"/moodlist.bml\" TARGET=moods>$ML{'.moodicons.preview'}</A>)\n";
     $checked = $u->{'opt_forcemoodtheme'} eq "Y" ? "CHECKED" : "";
     $ret .= "<BR><INPUT TYPE=CHECKBOX $checked NAME=opt_forcemoodtheme> $ML{'.moodicons.opt.forcefriends.about'}";
     $ret .= "</div>";
     
     ###
     ### FRIENDS VIEW OPTIONS
     ###
     $ret .= "<?h2 $ML{'.friends.head'} h2?><?p $ML{'.friends.about'} p?>";
     $ret .= "<P><TABLE>\n";

     my $checked;
     $checked = $u->{'opt_usesharedpic'} ? "CHECKED" : "";
     $ret .= "<TR VALIGN=MIDDLE><TD WIDTH=50 ALIGN=RIGHT><INPUT TYPE=CHECKBOX NAME=opt_usesharedpic $checked></TD><TD><B>$ML{'.friends.opt.usesharedpic.head'}</B></TD></TR>\n";
     $ret .= "<TR><TD>&nbsp;</TD><TD>$ML{'.friends.opt.usesharedpic.about'}</TD></TR>\n";
     
     $ret .= "</TABLE>\n";

     # Journal domain stuff
     if ($LJ::OTHER_VHOSTS && LJ::get_cap($u, "userdomain")) {
         $ret .= "<?h2 $ML{'.domainalias.head'} h2?><?p $ML{'.domainalias.about'} ";
         $ret .= "<blockquote>$ML{'.domainalias.domainname'} <input name='journaldomain' size='30' maxlength='80' value='";
         $ret .= LJ::ehtml($u->{'journaldomain'});
         $ret .= "'><br />$ML{'.domainalias.example'}</blockquote>";
         $ret .= BML::ml(".domainalias.helptext", {'sitename' => $LJ::SITENAME})." p?>";
     }

     unless ($u->{'stylesys'} == 2) 
     {
         ### ending submit block
         $ret .= "<?h1 $ML{'.done.head'} h1?><?p $ML{'.done.text'} p?>\n";
         $ret .= "<?standout <INPUT TYPE=SUBMIT VALUE=\"$ML{'.done.btn.savechanges'}\"> standout?>\n";
         
         $ret .= "<?hr?>\n";

         ### overrides
         # first, load the overrides if they use 'em:
         my $overrides = "";
         if ($u->{'useoverrides'} eq "Y")
         {
             $sth = $dbr->prepare("SELECT override FROM overrides WHERE user=$quser");
             $sth->execute;
             ($overrides) = $sth->fetchrow_array;
             LJ::text_out(\$overrides);
         }
         
         $ret .= "<?h1 $ML{'.overrides.head'} h1?><?p $ML{'.overrides.about'} p?><?p <FONT SIZE=+1><B>$ML{'.overrides.warning'}</B></FONT> p?>\n";
         $ret .= "<?p $ML{'.overrides.note'} p?>\n";
         $ret .= "<?standout <B>$ML{'.overrides.box.head'}</B><BR><TEXTAREA NAME=\"overrides\" COLS=60 ROWS=8 WRAP=OFF>";
         $ret .= BML::eall($overrides);
         $ret .= "</TEXTAREA> standout?>";
     }

     $ret .= "<?h1 $ML{'.journalstatus.head'} h1?><?p $ML{'.journalstatus.about'} p?>";
     my %statvis = ("V" => "$ML{'.journalstatus.select.activated'}", "D" => "$ML{'.journalstatus.select.deleted'}");
     if ($u->{'statusvis'} eq "S") {
         $statvis = ("S" => "$ML{'.journalstatus.select.suspended'}");
     }
     $ret .= "<UL>$ML{'.journalstatus.select.head'} <SELECT NAME=\"statusvis\">";
     foreach (reverse sort keys %statvis) {
         my $sel = $_ eq $u->{'statusvis'} ? " SELECTED" : "";
         $ret .= "<OPTION VALUE=\"$_\"$sel>$statvis{$_}\n";
     }
     $ret .= "</SELECT></UL>\n";
     
     ### ending submit block
     $ret .= "<?h1 $ML{'.done.head'} h1?><?p $ML{'.done.text'} p?>\n";
     $ret .= "<?standout <INPUT TYPE=SUBMIT VALUE=\"$ML{'.done.btn.savechanges'}\"> standout?>\n";
     $ret .= "</FORM>\n";

     return $ret;
 }

 if ($mode eq "domodify")
 {
     return "<?requirepost?>" unless LJ::did_post();

     my @errors = ();
     my $state = "";

     # setup what we're gonna update in the user table:
     my %update = ();

     # validate moodthemeid
     # mood theme, make sure they're allowed to use it
     my $moodthemeid = $FORM{'moodthemeid'}+0;
     if ($moodthemeid) {
         my ($mownerid, $mpublic) = $dbr->selectrow_array("SELECT ownerid, is_public FROM moodthemes ".
                                                          "WHERE moodthemeid=?", undef, $moodthemeid);
         $moodthemeid = 0 unless $mpublic eq 'Y' || $mownerid == $u->{'userid'};
     }
     $update{'moodthemeid'} = $moodthemeid;

     # color themes
     $update{'themeid'} = $FORM{'themetype'} eq "custom" ? 0 : $FORM{'themeid'};
     $update{'opt_forcemoodtheme'} = $FORM{'opt_forcemoodtheme'} ? "Y" : "N";
     
     if ($FORM{'themetype'} eq "custom") {
         my $dig = Digest::MD5::md5_hex(join(",", map { $FORM{"theme_cust:$_"} }
                                             map { $_->[0] } @LJ::S1::themecoltypes));
         if ($dig ne $FORM{'themecolors_dig'}) {
             my %cols;
             foreach my $col (@LJ::S1::themecoltypes) {
                 my $val = $FORM{"theme_cust:$col->[0]"};
                 next if length($val) > 20;
                 next unless ($val =~ /^\#[a-f0-9]{6,6}$/i ||
                              $val !~ /[^\s\w]/);
                 $cols{$col->[0]} = $val;
             }

             my $dbcm = LJ::get_cluster_master($u, 1);
             $dbcm->do("INSERT IGNORE INTO s1usercache (userid) VALUES (?)", undef, $u->{'userid'});
             $dbcm->do("UPDATE s1usercache SET color_stor=? WHERE userid=?", undef, 
                       Storable::freeze(\%cols), $u->{'userid'});

             $dbh->do("DELETE FROM themecustom WHERE user=$quser")
                 if $dbh->selectrow_array("SELECT user FROM themecustom ".
                                          "WHERE user=? LIMIT 1", undef, $u->{'user'});
         }
     }

     # update 'overrides' table
     if ($FORM{'overrides'} !~ /\S/) 
     {
         $dbh->do("DELETE FROM overrides WHERE user=$quser");
         $update{'useoverrides'} = "N";
     }
     else
     {
         my $oldoverrides = "";
         if ($u->{'useoverrides'} eq "Y") {
             $sth = $dbr->prepare("SELECT override FROM overrides WHERE user=$quser");
             $sth->execute;
             ($oldoverrides) = $sth->fetchrow_array;
         }

         # This allows users to keep their current illegal overrides,
         # but they may not create new ones nor edit the ones they already have.
         # They may only delete or keep illegal overrides.
         my %overrides = ();
         my %newoverrides = ();
         LJ::parse_vars(\$oldoverrides,\%overrides);
         LJ::parse_vars(\$FORM{'overrides'},\%newoverrides);
         
         # head overrides should only have valid head elements in them
         foreach my $a (qw(GLOBAL LASTN FRIENDS CALENDAR DAY)) {
             my $sec = "${a}_HEAD";
             next unless $newoverrides{$sec} ne $overrides{$sec};

             my $testtag = sub {
                 my $tag = lc(shift);
                 return "<$tag" if ($tag eq "title" || $tag eq "base" ||
                                    $tag eq "style" || $tag eq "link" ||
                                    $tag eq "meta" || $tag  eq "xx");
                 return "<xx-$tag";
             };
             $newoverrides{$sec} =~ s/\<(\w+)/$testtag->($1)/eig;
             $newoverrides{$sec} =~ s/\<\/head/\<\/xx-head/ig;
         }

         # load all the properties to see which ones are overridable
         my @vars;
         LJ::load_objects_from_file("$LJ::HTDOCS/vars.dat", \@vars);
         foreach my $v (@vars) {
             my $ov = $v->{'props'}->{'override'}; 
             if ($ov eq "yes" || $ov eq "only" || $capstyles) {
                 my $name = $v->{'name'};
                 $ret .= "<B>$name</B><br>";
                 if (defined $newoverrides{$name}) {
                     $overrides{$name} = $newoverrides{$name};
                 }
             }
         }
         
         # make the new override code we'll put in the database
         my $overr='';
         foreach (keys %overrides) {
             if ($newoverrides{$_}) {
                 if ($overrides{$_} =~ /\n/) {
                     $overr .= "$_<=\n".$overrides{$_}."\n<=$_\n\n";
                 } else {
                     $overr .= "$_=>".$overrides{$_}."\n\n";
                 }
             }
         }
         
         if ($overr !~ /\S/) {
             $dbh->do("DELETE FROM overrides WHERE user=$quser");
             $update{'useoverrides'} = "N";
         } else {
             my $qoverrides = $dbh->quote($overr);
             $dbh->do("REPLACE INTO overrides SET user=$quser, override=$qoverrides");
             $update{'useoverrides'} = "Y";

             my $dbcm = LJ::get_cluster_master($u, 1);
             $dbcm->do("UPDATE s1usercache SET override_stor=NULL WHERE userid=?", undef, $u->{'userid'});
         }
     }

     if ($dbh->err) { 
         return "<?h1 $ML{'error'} h1?><?p $ML{'error.dberror'} <B>" . $dbh->errstr . "</B> p?>"; 
     }

     # update 'user' table
     my $sets = "";
     foreach (keys %update) {
         $sets .= "$_=" . $dbh->quote($update{$_}) . ",";
     }

     ### change their visiblilty (deletion) status if they changed it
     if ($u->{'statusvis'} ne "S" && 
         ($u->{'statusvis'} ne $FORM{'statusvis'}) &&
         ($FORM{'statusvis'} eq "D" || $FORM{'statusvis'} eq "V"))
     {
         my $qstatvis = $dbh->quote($FORM{'statusvis'});
         $sets .= "statusvis=$qstatvis,statusvisdate=NOW(),";
     }
     chop $sets;
     my $sql = "UPDATE user SET $sets WHERE user=$quser";
     $dbh->do($sql);
     if ($dbh->err) { return "<?h1 $ML{'error'} h1?><?p $ML{'error.dberror'} <B>" . $dbh->errstr . "</B> p?>"; }

     # what userprops we'll be setting.
     my %uprop;
     $uprop{'opt_usesharedpic'} = $FORM{'opt_usesharedpic'} ? "1" : "0";

     # set all the styles
     {
         my @picked = ();
         foreach my $view (@LJ::views)
         {
             my $sid = $FORM{"s1_${view}_style"}+0;
             if ($sid) {
                 $uprop{"s1_${view}_style"} = $sid;
                 push @picked, $sid;
             }
         }
         unless ($capstyles) {
             # verify they haven't forged the style numbers
             my $in = join(",", 0, @picked);
             
             $sth = $dbr->prepare("SELECT COUNT(*) FROM style WHERE ".
                                  "((user='system' AND is_public='Y') OR user=$quser) ".
                                  "AND styleid IN ($in)");
             $sth->execute;
             if ($dbr->err) { return $dbr->errstr; }
             my ($count) = $sth->fetchrow_array;
             if ($count != scalar(@picked)) {
                 my $ret = "<?h1 $ML{'error'} h1?><?p $ML{'.error.stylenotavailable'} p?>";
                 return $ret;
             }
         }
     }

     if (exists $FORM{'journaldomain'} && 
         $u->{'journaldomain'} ne $FORM{'journaldomain'}) 
     {
         $FORM{'journaldomain'} =~ s!^(http://)?(www\.)?!!;
         my $dom = lc($FORM{'journaldomain'});
         my $qdom = $dbh->quote($dom);
         if ($dom) {
             $dbh->do("INSERT INTO domains VALUES ($qdom, $u->{'userid'})");
         } else {
             $dbh->do("DELETE FROM domains WHERE userid=$u->{'userid'}");
         }
         if ($dbh->err) {
             my $otherid = $dbh->selectrow_array("SELECT userid FROM domains WHERE domain=$qdom");
             return "<?h1 $ML{'error'} h1?><?p $ML{'.error.dupdomainalias'} p?>"
                 if $otherid != $u->{'userid'};
         }
         if ($u->{'journaldomain'}) {
             $dbh->do("DELETE FROM domains WHERE userid=$u->{'userid'} AND domain <> $qdom");
         }
         $uprop{'journaldomain'} = $dom;
     }

     ### change any of the userprops ?
     foreach my $uprop (keys %uprop) {
         next if ($FORM{$uprop} eq $u->{$uprop});
         LJ::set_userprop($dbs, $u->{'userid'}, $uprop, $uprop{$uprop});
     }

     # tell the user all is well
     return "<?h1 $ML{'.success.head'} h1?><?p ".BML::ml(".success.text", {'url' => "$LJ::SITEROOT/users/$user/"})." p?>";
 }

 return "$ML{'error.unknownmode'}";

_code?>

<=body
page?><?_c <LJDEP>
link: htdocs/moodlist.bml, htdocs/developer/index.bml, htdocs/developer/varlist.bml, htdocs/styles/create.bml
post: htdocs/modify_do.bml
</LJDEP> _c?>

