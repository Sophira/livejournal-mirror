<?_info
nocache=>1
_info?><?page
title=><?_ml .title _ml?>
body<=

<?_code
{
    use strict;
    use vars qw(%GET %POST);

    LJ::set_active_crumb('delcomment');

    my $remote = LJ::get_remote();
    return LJ::bad_input($ML{'error.noremote'})
        unless $remote;

    # $u is user object of journal that owns the talkpost
    my $u = LJ::load_user($GET{'journal'});
    return LJ::bad_input($ML{'error.nojournal'})
        unless $u;

    return $LJ::MSG_READONLY_USER if LJ::get_cap($u, "readonly");

    my $dbcr = LJ::get_cluster_def_reader($u);
    return "<?h1 $ML{'Error'} h1?><?p $ML{'error.nodb'} p?>"
        unless $dbcr;

    # $tp is a hashref of info about this individual talkpost row
    my $tpid = $GET{'id'} >> 8;
    my $tp = $dbcr->selectrow_hashref("SELECT jtalkid AS 'talkid', nodetype, state, " .
                                      "nodeid AS 'itemid', parenttalkid, journalid, posterid " .
                                      "FROM talk2 ".
                                      "WHERE journalid=? AND jtalkid=?",
                                      undef, $u->{'userid'}, $tpid);

    return LJ::bad_input($ML{'.error.nocomment'})
        unless $tp;

    return LJ::bad_input($ML{'.error.invalidtype'})
        unless $tp->{'nodetype'} eq 'L';

    return LJ::bad_input($ML{'.error.alreadydeleted'})
        if $tp->{'state'} eq "D";

    # get username of poster
    $tp->{'userpost'} = LJ::get_username($tp->{'posterid'});

    # userid of user who posted journal entry
    my $jposterid = $dbcr->selectrow_array("SELECT posterid FROM log2 WHERE " .
                                           "journalid=? AND jitemid=?",
                                           undef, $u->{'userid'}, $tp->{'itemid'});
    my $jposter = LJ::load_userid($jposterid);

    # can $remote delete this comment?
    unless (LJ::Talk::can_delete($remote, $u, $jposter, $tp->{'userpost'})) {
        my $err = $u->{'journaltype'} eq 'C' ? $ML{'.error.cantdelete.comm'} : $ML{'.error.cantdelete'};
        return "<?h1 $ML{'Error'} h1?><?p $err p?>";
    }

    my $can_manage = LJ::can_manage($remote, $u);

    # can ban if can manage and the comment is by someone else and not anon
    my $can_ban = $can_manage && $tp->{'posterid'} 
                  && $remote && $remote->{'userid'} != $tp->{'posterid'}; 
    my $can_delthread = $can_manage;


    ### perform actions
    if (LJ::did_post() && $POST{'confirm'}) {
        # mark this as spam?
        LJ::Talk::mark_comment_as_spam($u, $tp->{talkid})
            if $POST{spam};

        # delete entire thread? or just the one comment?
        if ($POST{delthread} && $can_delthread) {
            # delete entire thread ...
            LJ::Talk::delete_thread($u, $tp->{'itemid'}, $tpid);
        } else {
            # delete single comment...

            # if it's screened, unscreen it first to properly adjust
            # replycount and the hasscreened logprop
            LJ::Talk::unscreen_comment($u, $tp->{'itemid'}, $tpid)
                if $tp->{'state'} eq 'S';

            # now do the deletion
            my $num = LJ::delete_comments($u, "L", $tp->{'itemid'}, $tpid);
            LJ::replycount_do($u, $tp->{'itemid'}, "decr", $num);
            LJ::Talk::update_commentalter($u, $tp->{'itemid'});
        }

        # ban the user, if selected
        my $msg;
        if ($POST{'ban'} && $can_ban) {
            LJ::set_rel($u->{'userid'}, $tp->{'posterid'}, 'B');
            $msg = BML::ml('.success.andban', { 'user' => LJ::ljuser($tp->{'userpost'}) });
        }
        $msg ||= $ML{'.success.noban'};
        $msg .= "<?p $ML{'.success.spam'} p?>" if $POST{spam};

        return "<?h1 $ML{'.success.head'} h1?><?p $msg p?>";
    }

    ### show confirmation form

    my $ret;
    $ret .= "<?h1 $ML{'.confirm.head'} h1?>";
    $ret .= "<?p $ML{'.confirm.body'} p?>";
    $ret .= "<form method='post' action='delcomment.bml?";
    $ret .= "journal=$u->{'user'}&id=$GET{'id'}'>\n";
    $ret .= "<?standout ";

    $ret .= "<div align='center' style='margin: 8px'>" . LJ::html_submit('confirm', $ML{'.confirm.submit'}) . "</div>\n";

    if ($can_ban) {
        $ret .= "<div>" . LJ::html_check({ 'type' => 'check', 'name' => 'ban', 'id' => 'ban' });
        $ret .= "<label for='ban'>";
        $ret .= BML::ml('.confirm.banuser', { 'user' => LJ::ljuser($tp->{'userpost'}) });
        $ret .= "</label></div>";
    }

    if ($tp->{'posterid'} != $remote->{'userid'}) { # Despite the idea of natural selection, don't let users report their own comments as spam
        $ret .= "<div>" . LJ::html_check({name => 'spam', id => 'spam'});
        $ret .= "<label for='spam'>$ML{'.confirm.spam'}</label></div>";
    }

    if ($can_delthread) {
        $ret .= "<div>" . LJ::html_check({name => 'delthread', id => 'delthread'});
        $ret .= "<label for='delthread'>$ML{'.confirm.delthread'}</label></div>";
    }

    $ret .= " standout?>";

    if ($can_manage) {
        my $msg = BML::ml('.changeoptions', { 'link' =>
            "<a href='/editinfo.bml?authas=$u->{'user'}'>$ML{'/editinfo.bml.title'}</a>" });
        $ret .= "<?p $msg p?>";
    }

    $ret .= "</form>\n";

    return $ret;
}
_code?>

<=body
page?><?_c <LJDEP>
link: htdocs/editinfo.bml
post: htdocs/delcomment.bml
</LJDEP> _c?>
