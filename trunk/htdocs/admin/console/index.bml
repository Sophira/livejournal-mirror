(=_CODE

 use strict;
 use vars qw(%FORM %cmd);

 my ($ret, $sth);

 my $dbs = LJ::get_dbs();
 my $dbh = $dbs->{'dbh'};
 my $dbr = $dbs->{'reader'};

 my $commands = $FORM{'commands'};
 my $remote = LJ::get_remote($dbs);

 if ($commands) 
 {
     unless (LJ::did_post()) {
	 return "<b>Error:</b> requires post.";
     }

     $ret .= "[ <A HREF=\"./\">console</A> | <A HREF=\"reference.bml\">reference</A> ]<P>";

     foreach my $cmd (split(/\n/, $commands))
     {
	 next unless ($cmd =~ /\S/);
	 $cmd =~ s/^\s+//; $cmd =~ s/\s+$//;
	 $cmd =~ s/\t/ /g;

	 my $state;  # w=whitespace, a=arg, q=quote, e=escape (next quote isn't closing)
	 $state = "a";
	 
	 my @args;
	 my $argc = 0;
	 my $len = length($cmd);
	 my ($lastchar, $char);

	 for (my $i=0; $i<$len; $i++) 
	 {
	     $lastchar = $char;
	     # $ret .= "<B><TT>[$lastchar]</TT></B> argc=$argc state=$state<BR>";
	     $char = substr($cmd, $i, 1);

	     ### jump out of quots
	     if ($state eq "q" && $char eq '"') {
		 $state = "w";
		 next;
	     }
	     
	     ### keep ignoring whitespace
	     if ($state eq "w" && $char eq " ") {
		 next;
	     }
	     
	     ### finish arg if space found
	     if ($state eq "a" && $char eq " ") {
		 $state = "w";
		 next;
	     }
	 
	     ### if non-whitespace encountered, move to next arg
	     if ($state eq "w") {
		 $argc++;
		 if ($char eq '"') {
		     $state = "q";
		     next;
		 } else {
		     $state = "a";
		 }
	     }

	     ### don't count this character if it's a quote
	     if ($state eq "q" && $char eq '"') {
		 $state = "w";
		 next;
	     }

	     ### respect backslashing quotes inside quotes
	     if ($state eq "q" && $char eq "\\") {
		 $state = "e";
		 next;
	     }

	     ### after an escape, next character is literal
	     if ($state eq "e") {
		 $state = "q";
	     }

	     $args[$argc] .= $char;

	 }

	 if (@args) {
	     my $first = 1;
	     $ret .= "<P><TABLE BORDER=1 CELLPADDING=5><TR>";
	     foreach (@args) {
		 if ($first) {
		     $ret .= "<TD><B>$_</B></TD>";
		     $first = 0;
		 } else {
		     $ret .= "<TD>$_</TD>";
		 }
	     }
	     $ret .= "</TR></TABLE>";

	     my @output;
	     my $rv;
	     
	     $rv = LJ::Con::execute($dbh, $remote, \@args, \@output);

	     unless ($rv) { $ret .= "<P><B><FONT COLOR=#FF0000>Failed!</FONT></B>"; }
	     if (@output) {
		 $ret .= "<PRE><B>";
		 foreach my $line (@output) {
		     my $color = "#000000";
		     if ($line->[0] eq "error") { 
			 $color = "#FF0000";
		     } 
		     if ($line->[0] eq "info") { 
			 $color = "#008800";
		     } 

		     $ret .= "<FONT COLOR=$color>$line->[1]</FONT>\n";

		 }
		 $ret .= "</B></PRE>";
	     }

	     
	 }
     }

     $ret .= "<form method=post><p>";
     $ret .= "<tt>enter commands:</tt><br>";
     $ret .= "<textarea name=commands rows=3 cols=60 wrap=off></textarea> ";
     $ret .= "<input type=submit value=\"execute\"></form>\n";

     return $ret;     
     
 }
 else 
 {
     $ret .= "[ console | <A HREF=\"reference.bml\">reference</A> ]<P>";
     
     $ret .= "<FORM METHOD=POST><TABLE WIDTH=400><TR VALIGN=BOTTOM>";
     $ret .= "<TD><IMG SRC=\"$LJ::IMGPREFIX/nerd_small.jpg\" WIDTH=167 HEIGHT=169 HSPACE=2 VSPACE=2></TD>";
     $ret .= "<TD><B><TT>command console.</TT></B>";
     $ret .= "<P>welcome to the livejournal console.  from here administrators can do administrative type things.  you will forget the commands, so there is a <A HREF=\"reference.bml\">reference</A>.</TD>";
     $ret .= "</TR>";
     $ret .= "<TR><TD COLSPAN=2>";
     $ret .= "<P><tt>enter commands:</tt><BR>";
     $ret .= "<TEXTAREA NAME=commands ROWS=10 COLS=60 WRAP=OFF></TEXTAREA></TD></TR>\n";
     $ret .= "<TR><TD COLSPAN=2 ALIGN=RIGHT><INPUT TYPE=SUBMIT VALUE=\"execute\"></P></TD></TR></TABLE></FORM>\n";
     return $ret;
 }

_CODE=)(=_C <LJDEP>
lib: cgi-bin/console.pl, cgi-bin/ljlib.pl
link: htdocs/admin/console/reference.bml
post: htdocs/admin/console/index.bml
</LJDEP> _C=)
