<?page
title=><?_ML .title _ML?>
body<=

<?_code
{
    use strict;
    use vars qw(%GET %POST);

    return LJ::server_down_html() if $LJ::SERVER_DOWN;
    return "<?badinput?>" unless LJ::text_in(\%POST);

    LJ::set_active_crumb('editentries_do');

    # some definitions:
    # - $remote    = remote user
    # - $u         = authas user (remote has permission to be this person)
    # - $usejournal = alternate journal we are working with
    #   - if we have $usejournal, then we also have $usejournal_u
    #     which is a user object for the $usejournal user

    # only verify that they are logged in for now
    my $remote = LJ::get_remote();
    return LJ::bad_input($ML{'error.noremote'})
        unless $remote;

    # are they asking to be authed as someone else?
    my $authas = $GET{'authas'} || $remote->{'user'};
    my $u = LJ::get_authas_user($authas);
    return LJ::bad_input("You could not be authenticated as the specified user.")
        unless $u;
    return LJ::bad_input("You must be authenticated as a person.")
        unless $u->{'journaltype'} eq 'P';

    # are we modify a community post?
    my $usejournal = $GET{'usejournal'} || $POST{'usejournal'} || $GET{'journal'};
    undef $usejournal if $usejournal eq $u->{'user'}; # ignore if it's the user

    # user object for community if we're modifying one
    my $usejournal_u;
    if ($usejournal) {
        $usejournal_u = LJ::load_user($usejournal);
        return LJ::bad_input("The community you selected does not exist.")
            unless $usejournal_u;
    }

    # extra get arguments
    my $getextra;
    $getextra .= "authas=$authas&" if $authas ne $u->{'user'};
    $getextra .= "usejournal=$usejournal&" if $usejournal;
    chop $getextra;
    $getextra = "?$getextra" if $getextra;

    ###
    ### HAVE AN ITEMID TO EDIT
    ###

    if ($GET{'itemid'} || $POST{'itemid'}) {
        
        # the 'itemid' form element is really an 'itemid'
        my $ditemid = $GET{'itemid'} || $POST{'itemid'};
        my $anum = $ditemid % 256;
        my $itemid = $ditemid >> 8;

        # do getevents request
        my %res = ();
        LJ::do_request({ 'mode' => 'getevents',
                         'selecttype' => 'one',
                         'ver' => $LJ::PROTOCOL_VER,
                         'user' => $u->{'user'},
                         'usejournal' => $usejournal,
                         'itemid' => $itemid },
                       \%res,
                       { "noauth" => 1,
                         'u' => $u }
                       );

        # was there a protocol error?
        return "<?h1 $ML{'Error'} h1?><?p $res{'errmsg'} p?>"
            unless $res{'success'} eq 'OK';

        # does the requested entry exist?
        return "<?h1 $ML{'Error'} h1?><?p $ML{'.error.nofind'} p?>"
            unless $res{'events_count'} && $res{'events_1_anum'} == $anum;

        # are we authorized to edit other peoples' posts in this community?
        my $disabled_save = 0;
        my $disabled_delete = 0;
        my $disabled_spamdelete = 0;
        if ($usejournal && $res{'events_1_poster'} ne $u->{'user'}) {
            $disabled_delete = ! LJ::can_delete_journal_item($u, $usejournal_u);
            $disabled_save++;
        }

        $disabled_spamdelete = $disabled_delete || !$usejournal || ($res{'events_1_poster'} eq $u->{'user'});

        ###
        ### SAVE EDITS
        ###

        # are we spellchecking before we post?
        my $spellcheck_html;
        my $did_spellcheck;
        if ($LJ::SPELLER && $POST{'do_spellcheck'}) {
            my $s = new LJ::SpellCheck { 'spellcommand' => $LJ::SPELLER,
                                         'color' => '<?hotcolor?>', };
            my $event = LJ::ehtml($POST{'event'});
            $spellcheck_html = $s->check_html(\$event);
            $did_spellcheck++;
        }

        # they clicked the save or delete button
        if (!$spellcheck_html && ($POST{'action:save'} || $POST{'action:delete'} || $POST{'action:deletespam'})) {

            my %req = (
                       'mode' => 'editevent',
                       'ver' => $LJ::PROTOCOL_VER,
                       'user' => $u->{'user'},
                       'usejournal' => $usejournal,
                       'itemid' => $itemid,
                       );

            # copy some things from %POST
            foreach (qw(event subject year mon day hour min
                        prop_picture_keyword prop_current_moodid
                        prop_current_mood prop_current_music
                        prop_opt_screening)) {
                $req{$_} = $POST{$_};
            }

            # deleting the event? protocol wants blank event body
            $req{'event'} = '' if $POST{'action:delete'} || $POST{'action:deletespam'};

            # copy some opts, but make sure they are 1 : 0 explicitly
            foreach (qw(preformatted nocomments backdated noemail)) {
                $req{"prop_opt_$_"} = $POST{"prop_opt_$_"} ? 1 : 0;
            }

            ### see if an "other" mood they typed in has an equivalent moodid
            if ($POST{'prop_current_mood'}) {
                if (my $id = LJ::mood_id($POST{'prop_current_mood'})) {
                    $req{'prop_current_moodid'} = $id;
                    $req{'prop_current_mood'} = '';  # clear current_mood
                }
            }

            # security
            my $sec = "public";
            my $amask = 0;
            if ($POST{'security'} eq "private") { $sec = "private"; }
            if ($POST{'security'} eq "friends") { $sec = "usemask"; $amask = 1; }
            if ($POST{'security'} eq "custom") { 
                $sec = "usemask"; 
                foreach my $bit (1..30) {
                    next unless $POST{"custom_bit_$bit"};
                    $amask |= (1 << $bit);
                }
            }
            $req{'security'} = $sec;
            $req{'allowmask'} = $amask;

            # mark as spam, if need be
            LJ::mark_entry_as_spam($usejournal_u, $itemid) if $POST{'action:deletespam'};

            # do editevent request
            LJ::do_request(\%req, \%res, { 'noauth' => 1, 'u' => $u });

            # check response
            unless ($res{'success'} eq "OK") {
                return "<?h1 $ML{'Error'} h1?><?p $ML{'.error.modify'} <ul><li><b>$res{'errmsg'}</b></li></ul> p?>";
            }

            # deleted
            unless ($req{'event'}) {
                my $result = "<?h1 $ML{'.success.head'} h1?><?p $ML{'.success.delete'} p?>";
                $result .= "<?p $ML{'.success.deletespam'} p?>" if $POST{'action:deletespam'};
                return $result;
            }

            # modified
            return BML::redirect(LJ::item_link($usejournal ? $usejournal_u : $u, $itemid, $res{'anum'}));
        }


        ###
        ### SHOW EDIT FORM
        ###

        # get friend groups unless community
        my $gfg;
        $gfg = LJ::Protocol::do_request("getfriendgroups", {
            'username' => $u->{'user'},
            'ver' => $LJ::PROTOCOL_VER,
        }, undef, {
            'noauth' => 1,
            'u' => $u
        }) unless $usejournal;

        # use standard props hash
        my %props = ();
        for (my $i = 1; $i <= $res{'prop_count'}; $i++) {
            $props{$res{"prop_${i}_name"}} = $res{"prop_${i}_value"};
        }

        # start edit form
        my $ret;

        $ret .= "<div style='width: 90%'><form method='post' action='editjournal_do.bml$getextra'>\n";
        $ret .= LJ::html_hidden('itemid', $ditemid) . "\n";

        # user clicked the preview button
        if ($POST{'action:preview'}) {
            my ($event, $subject) = ($POST{'event'}, $POST{'subject'});
            LJ::CleanHTML::clean_subject(\$subject);
            LJ::CleanHTML::clean_comment(\$event, $POST{'prop_opt_preformatted'});
            $ret .= "<h2>$ML{'.preview.header'}</h2>";
            $ret .= "<?p $ML{'.preview.text'} p?>";
            $ret .= "<b>Subject</b>: $subject<br /><br />";
            $ret .= "<b>Event</b>: <br/>";
            $ret .= $event;
            $ret .= '<br /><br />';
            $ret .= LJ::html_submit('action:save', $ML{'.btn.save'},
                                    { 'disabled' => $disabled_save });
            $ret .= '<br /><br />';

            $res{'events_1_event'} = $POST{'event'};
            $res{'events_1_subject'} = $POST{'subject'};
        }

        $ret .= "<?h1 $ML{'.title'} h1?>\n";
        $ret .= "<?p $ML{'.body'} p?>\n";

        # table of date/time info
        my ($year, $mon, $mday, $hour, $min) = split(/\D/, $res{"events_1_eventtime"});

        $ret .= "<table>\n";
        $ret .= "<tr><td align='right'>$ML{'.date'}<br /><i>(yyyy-mm-dd)</i></td>";
        $ret .= "<td>" . LJ::html_text({ 'name' => 'year', 'value' => $POST{'year'} || $year,
                                         'size' => '5', 'maxlength' => '4' }) . "-";
        $ret .= LJ::html_text({ 'name' => 'mon', 'value' => $POST{'mon'} || $mon,
                                'size' => '3', 'maxlength' => '2' }) . "-";
        $ret .= LJ::html_text({ 'name' => 'day', 'value' => $POST{'day'} || $mday,
                                'size' => '3', 'maxlength' => '2' }) . "</td>\n";

        $ret .= "<td align='right'>$ML{'.localtime'}<br /><i>($ML{'.timeformat'})</i></td><td>";
        $ret .= LJ::html_text({ 'name' => 'hour', 'value' => $POST{'hour'} || $hour,
                                'size' => '3', 'maxlength' => '2' }) . ":";
        $ret .= LJ::html_text({ 'name' => 'min', 'value' => $POST{'min'} || $min,
                                'size' => '3', 'maxlength' => '2' }) . "</td></tr>\n";
        $ret .= "</table>\n";

        # subject
        $ret .= "<p>$ML{'.subject'}<br />";
        $ret .= LJ::html_text({ 'name' => 'subject', 'value' => $res{'events_1_subject'},
                                'size' => '60', 'maxlength' => '255' }) . "\n";

        # spell checked entry
        $ret .= "<p><b>$ML{'/update.bml.spellchecked'}</b><br />$spellcheck_html</p>" if $spellcheck_html;
        
        # event body
        my $postedby = " (Posted by: " . LJ::ljuser($res{'events_1_poster'}) . ")" if $usejournal;
        $ret .= "<p><b>$ML{'.event'}</b>$postedby<br />";
        $ret .= LJ::html_textarea({ 'name' => 'event', 'value' => LJ::durl($res{'events_1_event'}), 'rows' => '12',
                                    'cols' => '60', 'wrap' => 'soft', 'style' => 'width: 99%;' }) . "</p>\n";

        # spell check checkbox
        if ($LJ::SPELLER) {
            $ret .= LJ::html_check({ 'name' => 'do_spellcheck', 'id' => 'do_spellcheck' });
            $ret .= "<label for='do_spellcheck'>$ML{'.opt.spellcheck'}</label>";
        }
        
        # security
        $ret .= "<p><b>$ML{'label.security.head'}</b> ";
        my @secs = ("public" => $ML{'label.security.public'}, "friends" => $ML{'label.security.friends'});
        push @secs,  ("private" => $ML{'label.security.private'}) unless $usejournal;
        
        # custom friend groups - wont' happen if $usejournal
        my @opts;
        if ($gfg && @{$gfg->{'friendgroups'}}) {
            push @secs, ("custom", $ML{'label.security.custom'});
            push @opts, ("onchange" => "document.getElementById('custom_boxes').style.display = (this.selectedIndex == 3) ? 'block' : 'none';");
        }
        
        # selected mark
        my $curmask = $res{'events_1_allowmask'};
        my $cursec = $POST{'security'} || $res{'events_1_security'};
        if ($cursec eq 'usemask') {
            $cursec = $curmask == 1 ? "friends" : "custom";
        }

        # show drop-down
        $ret .= LJ::html_select({ 'name' => 'security','selected' => $cursec, @opts }, @secs);
        $ret .= LJ::help_icon("security", ' ') . "\n";
        
        # pop-in friend groups
        if ($gfg && @{$gfg->{'friendgroups'}}) {
            my $display = $cursec eq "custom" ? "block" : "none";
            $ret .= "<div id='custom_boxes' style='margin: 10px 0 10px 30px; display: $display;'>";
            foreach my $fg (@{$gfg->{'friendgroups'}}) {
                $ret .= LJ::html_check({ 'type' => 'check',
                                         'name' => "custom_bit_$fg->{'id'}",
                                         'id' => "custom_bit_$fg->{'id'}",
                                         'selected' => $POST{"custom_bit_$fg->{'id'}"} || $curmask+0 & 1 << $fg->{'id'} }) . " ";
                $ret .= "<label for='custom_bit_$fg->{'id'}'>" . LJ::ehtml($fg->{'name'}) . "</label><br />";
            }
            $ret .= "</div>\n";
        }

        # custom screening levels for this post
        $ret .= "<p><b>$ML{'label.screening.header'}</b> ";
        my @levels = ('', $ML{'label.screening.default'}, 'N', $ML{'label.screening.none'},
                      'R', $ML{'label.screening.anonymous'}, 'F', $ML{'label.screening.nonfriends'},
                      'A', $ML{'label.screening.all'});
        $ret .= LJ::html_select({ name => 'prop_opt_screening',
                                  selected => $POST{'prop_opt_screening'} || $props{opt_screening} }, @levels);
        $ret .= LJ::help_icon('screening', ' ');
        $ret .= "\n";
        
        ### opt_ checkboxes
        my $prop_check = sub {
            my $prop = shift;
            my $prop_ml = shift || $prop;
            my $dis = shift() ? 1 : 0;

            return "<b><label for='prop_opt_$prop'>" . $ML{".opt.$prop_ml"} . "</label></b> " .
                   LJ::html_check({ 'type' => 'check',
                                    'name' => "prop_opt_$prop",
                                    'id' => "prop_opt_$prop",
                                    'selected' => $POST{"prop_opt_$prop"} || $props{"opt_$prop"},
                                    'disabled' => $dis });
        };

        # backdating
        $ret .= "<p>" . $prop_check->('backdated', 'backdate', $usejournal) . " ";

        # don't auto-format
        $ret .= $prop_check->('preformatted', 'noformat') . LJ::help_icon("noautoformat", " ") . "</p>\n";

        # don't allow comments
        $ret .= "<p>" . $prop_check->('nocomments') . " ";

        # don't email the poster
        $ret .= $prop_check->('noemail') . "\n";

        # picture to use
        {
            my $pi = LJ::get_userpic_info($u);
            my @pics = sort keys %{$pi->{'kw'}};
               
            if (@pics) {
                $ret .= "<p><b>".BML::ml(".picture", { 'url' => "$LJ::SITEROOT/allpics.bml?user=$u->{'user'}" }) ."</b> ";
                $ret .= LJ::html_select({ 'name' => 'prop_picture_keyword',
                                          'selected' => $POST{'prop_picture_keyword'} || $props{'picture_keyword'} },
                                          '', $ML{'.default'},
                                          map { $_, $_ } @pics
                                       );
                $ret .= LJ::help_icon("userpics", " ") . "</p>\n";
            }
        }

        # current mood
        {
            my @moodlist = ('', $ML{'.noneother'});
            my $sel;

            my $moods = LJ::get_moods();
            foreach (sort { $moods->{$a}->{'name'} cmp $moods->{$b}->{'name'} } keys %$moods) {
                push @moodlist, ($_, $moods->{$_}->{'name'});

                if ($props{'current_mood'} eq $moods->{$_}->{'name'} ||
                    $props{'current_moodid'} == $_) {
                    $sel = $_;
                }
            }

            $sel = $POST{'prop_current_moodid'} if $POST{'prop_current_moodid'};
            $ret .= "<p><b>$ML{'.currmood'}</b>";
            $ret .= LJ::html_select({ 'name' => 'prop_current_moodid',
                                      'selected' => $sel }, @moodlist);
            $ret .= " $ML{'.other'} " . LJ::html_text({ 'name' => 'prop_current_mood',
                                                        'value' => $POST{'prop_current_mood'} || $props{'current_mood'},
                                                        'size' => '15', 'maxlength' => '30' });
        }	     

        ## current music
        $ret .= "<p><b>$ML{'.currmusic'}</b> ";
        $ret .= LJ::html_text({ 'name' => 'prop_current_music',
                                'value' => $POST{'prop_current_music'} || $props{'current_music'},
                                'size' => '40', 'maxlength' => '60' }) . "</p>\n";

        $ret .= "<?h1 $ML{'.save.head'} h1?><?p $ML{'.save.text'} p?>\n";
        $ret .= "<?standout ";
        $ret .= LJ::html_submit('action:save', $ML{'.btn.save'},
                                { 'disabled' => $disabled_save }) . " ";
        $ret .= LJ::html_submit('action:preview', $ML{'.btn.preview'}) . " ";
        $ret .= LJ::html_submit('action:delete', $ML{'.btn.delete'},
                                { 'disabled' => $disabled_delete,
                                  'onclick' => "return confirm('" . LJ::ejs($ML{'.delete.confirm'}) . "')" }) . " ";
        $ret .= "<br/><br/><center>" . LJ::html_submit('action:deletespam', $ML{'.btn.deletespam'},
                                { 'onclick' => "return confirm('" . LJ::ejs($ML{'.deletespam.confirm'}) . "')" }) . "</center>"
                                if !$disabled_spamdelete;
        $ret .= " standout?></form></div>\n";
        
        return $ret;
    }


    ###
    ### NO ITEMID - SELECT ENTRY TO EDIT
    ### 

    ### already authenticated from above

    return BML::redirect("$LJ::SITEROOT/editjournal.bml")
        unless LJ::did_post();

    my %res;
    my %req = (
               'mode' => 'getevents',
               'ver'  => $LJ::PROTOCOL_VER,
               'user' => $u->{'user'},
               'usejournal' => $usejournal,
               'noprops' => 1,
               );

    # last 1
    if ($POST{'selecttype'} eq "last") {
        $req{'selecttype'} = 'one';
        $req{'itemid'} = -1;

    # last n
    } elsif ($POST{'selecttype'} eq 'lastn') {
        $req{'selecttype'} = 'lastn';
        $req{'howmany'} = $POST{'howmany'};

    # day
    } elsif ($POST{'selecttype'} eq 'day') {
        $req{'selecttype'} = 'day';
        $req{$_} = $POST{$_} foreach qw(year month day);
    }

    # do getevents request
    LJ::do_request(\%req, \%res, { 'noauth' => 1, 'u' => $u });

    # check response
    unless ($res{'success'} eq "OK") {
        return "<?h1 $ML{'Error'} h1?>\n" .
               "<?p $ML{'.error.getting'} <ul><li><b><?_eh $res{'errmsg'} _eh?></b></li></ul> p?>";
    }

    # only one item returned?  go directly to edit it
    if ($res{'events_count'} == 1) {
        my $ditemid = ($res{'events_1_itemid'} << 8) + $res{'events_1_anum'};
        my $ditemid_get = $getextra ? "$getextra&itemid=$ditemid" : "?itemid=$ditemid";
        return BML::redirect("$LJ::SITEROOT/editjournal_do.bml$ditemid_get");
    }

    # how many results did we get?
    my $ev_count = $res{'events_count'};
    unless ($ev_count) { 
        if ($req{'selecttype'} eq 'lastn') {
            return "<?h1 No Entries Found h1?>\n" .
                   "<?p The selected journal has no entries. p?>\n";
        }

        return "<?h1 No Entries Found h1?>\n" .
               "<?p No entries match the criteria you specified. Please go back and adjust your search. p?>\n";
    }

    ### display results
    my $ret;
    $ret .= "<?h1 $ML{'.pickentry.head'} h1?><?p $ML{'.pickentry.text'} p?>\n";
    $ret .= "<form method='post' action='editjournal_do.bml$getextra'>\n";

    my %props = ();
    for (my $i=1; $i<=$res{'prop_count'}; $i++) {
        $props{$res{"prop_${i}_itemid"}}->{$res{"prop_${i}_name"}} = $res{"prop_${i}_value"};
    }

    for (my $i=1; $i<=$ev_count; $i++) {
        my $itemid = $res{"events_${i}_itemid"};
        my $ditemid = $itemid * 256 + $res{"events_${i}_anum"};
        
        $ret .= "<?hr?><table><tr valign='top'><td align='middle'>";
        $ret .= LJ::html_check({ 'type' => 'radio', 'value' => $ditemid,
                                 'name' => 'itemid', 'id' => "itemid-$ditemid" });
        $ret .= "</td><td>";

        $ret .= " <b><label for='itemid-$ditemid'>" . $res{"events_${i}_eventtime"} . "</label></b>";
        $ret .= " (Posted by: " . LJ::ljuser($res{"events_${i}_poster"}) . ")" if $usejournal;

        ### security indicator
        my $sec = ' ';
        if ($res{"events_${i}_security"} eq "private") {
            $sec .= BML::fill_template("securityprivate");
        } elsif ($res{"events_${i}_security"} eq "usemask") {
            $sec .= BML::fill_template("securityprotected");
        }
        $ret .= $sec;

        if (my $subj = $res{"events_${i}_subject"}) {
            LJ::CleanHTML::clean_subject_all(\$subj);
            $ret .= " <i>" . LJ::ehtml($subj) . "</i>";
        }
        $ret .= "<br />\n";
            
        my $event = LJ::ehtml(LJ::durl($res{"events_${i}_event"}));
        $event =~ s!\n!<br />!g;
        $ret .= $event;

        $ret .= "</td></tr></table>\n";
    }
        
    $ret .= "<?hr?><div style='margin-top: 20px;'><?h1 $ML{'.continue.head'} h1?></div>";
    $ret .= "<?p $ML{'.continue.text'} p?>\n";
    $ret .= "<?standout " . LJ::html_submit(undef, $ML{'.btn.edit'}) . " standout?></form>\n";
        
    return $ret;

}
_code?>

<=body
page?><?_c <LJDEP>
post: htdocs/editjournal_do.bml
link: htdocs/moodlist.bml, htdocs/users
lib: cgi-bin/cleanhtml.pl
</LJDEP> _c?>
