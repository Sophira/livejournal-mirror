#!/usr/bin/perl
use strict;
use lib "$ENV{LJHOME}/cgi-bin";
use LJ::Worker::TheSchwartz;
use Time::HiRes ();

TheSchwartz::Worker::SendEmail->set_HELO($LJ::DOMAIN);
TheSchwartz::Worker::SendEmail->set_keep_exit_status(sub { $LJ::KEEP_EXITSTATUS{'SendEmail'} || 0 });
TheSchwartz::Worker::SendEmail->set_on_5xx(sub {
    my ($rcpt, $job, $details) = @_;
    LJ::errobj('DieString', message => "send_email to $rcpt failed: $details")->log;
});

my $sclient = LJ::theschwartz();
$sclient->set_verbose(sub {
    my ($msg, $job) = @_;
    $msg =~ s/\s+$//;
    warn "$msg\n";
    return unless $LJ::DEBUG{'ts-sendemail'};
    return if $msg =~ /found no jobs$/;

    my $handle = $job->handle->as_string;
    my $now = sprintf("%0.05f", Time::HiRes::time());
    LJ::errobj('DieString', message => "ts_info: $now: [$handle] $msg")->log;
});

schwartz_decl('TheSchwartz::Worker::SendEmail');
schwartz_onidle(sub {
    $0 = "send-email [idle]";
});
schwartz_work();

# ----------------------------------------------------------------------------
# Thu Aug 17 15:01:00 2006 [144607433]: Error during TO phase to [@corset.1tv.ru]: 451 Greylisting enabled, try again in 1 minutes
# Thu Aug 17 15:02:16 2006 [144035925]: Error during TO phase to [@sherebon.ru]: 451 4.7.1 Greylisting in action, please come back in 00:09:00
# Thu Aug 17 15:05:37 2006 [144048251]: Error during TO phase to [@onet.com.ua]: 451 4.7.1 Greylisting in action, please come back in 00:58:00
# Thu Aug 17 15:02:19 2006 [144613489]: Error during TO phase to [@lindenlevy.com]: 451 4.7.1 Please try again later (TEMPFAIL)
# Thu Aug 17 15:02:51 2006 [144615371]: Error during TO phase to [@alumni.uwaterloo.ca]: 451 4.7.1 Greylisting in action, please come back later
# Thu Aug 17 15:04:51 2006 [144045433]: Error during TO phase to [@table2.com]: 450 <xxxtable2.com>: Recipient address rejected: Greylisted for 181 seconds
# Thu Aug 17 15:10:10 2006 [144643067]: Error during TO phase to [@hive-mind.net]: 450 4.7.1 <xxx@hive-mind.net>: Recipient address rejected: Greylisted for 300 seconds (see http://isg.ee.ethz.ch/tools/postgrey/help/hive-mind.net.html)
# Thu Aug 17 15:07:18 2006 [144632623]: Error during TO phase to [@balticom.lv]: 450 <livejournal.com[204.9.177.18]>: Client host rejected: Policy Rejection- GreyList learning. Please try later.
# Thu Aug 17 15:07:49 2006 [144634523]: Error during TO phase to [@hotkey.net.au]: 450 <xxxx@hotkey.net.au>: Recipient address rejected: Policy Rejection- Hotkey Greylisting in progress ... Please try again after 2 minutes
# 451 sender/recip/ip triad greylisted; retry AFTER A DECENT INTERVAL will succeed
# 451 Greylisting enabled, try again in 1 minutes
# 451 4.7.1 Greylisting in action, please come back in 00:09:00
# 451 4.7.1 Greylisting in action, please come back later
# 450 <xxx@xxx.com>: Recipient address rejected: Greylisted for 181 seconds
# 450 4.7.1 <xxx@xxx.com>: Recipient address rejected: Greylisted for 300 seconds (see http://isg.ee.ethz.ch/tools/postgrey/help/xxxxxx.html)
# 450 <livejournal.com[204.9.177.18]>: Client host rejected: Policy Rejection- GreyList learning. Please try later.
# 450 <xxx@xxx.com>: Recipient address rejected: Policy Rejection- Hotkey Greylisting in progress ... Please try again after 2 minutes
# 451 sender/recip/ip triad greylisted; retry AFTER A DECENT INTERVAL will succeed
# 450 <xxx@xxx.com>: Recipient address rejected: Greylisting in action. Please try delivery again in 240 seconds.
# 451 4.3.0 Temporarily greylisted as anti-spam measure.  Please try again.
# 451 <xxx@xxx.com>: Recipient address rejected: Service is greylisted.  Waiting for retransmit.

package TheSchwartz::Worker::SendEmail;
use base 'TheSchwartz::Worker';
use Net::DNS qw(mx);

use Storable;
my $resolver;
my $hello_domain;
my $keep_exit_status_for = 0;
my $on_5xx = sub {};

sub set_resolver {
    $resolver = $_[1];
}

sub resolver {
    return $resolver ||= Net::DNS::Resolver->new();
}

sub set_HELO {
    $hello_domain = $_[1];
}

sub set_on_5xx {
    $on_5xx = $_[1];
}

sub set_keep_exit_status { $keep_exit_status_for = $_[1] }

sub work {
    my ($class, $job) = @_;
    my $args = $job->arg;
    my $client = $job->handle->client;
    my $rcpts    = $args->{rcpts};     # arrayref of recipients

    my %dom_rcpts;  # domain -> [ $rcpt, ... ]
    foreach my $to (@$rcpts) {
        my ($host) = $to =~ /\@(.+?)$/;
        next unless $host;
        $host = lc $host;

        $dom_rcpts{$host} ||= [];
        push @{$dom_rcpts{$host}}, $to;
    }

    # uh, whack.
    unless (%dom_rcpts) {
        # FIXME: log or something.  for artur.
        $job->completed;
        return;
    }

    # split into jobs per host.
    if (scalar keys %dom_rcpts > 1) {
        $0 = "send-email [splitting]";
        my @new_jobs;
        foreach my $dom (keys %dom_rcpts) {
            my $new_args = Storable::dclone($args);
            $new_args->{rcpts} = $dom_rcpts{$dom};
            my $new_job = TheSchwartz::Job->new(
                                                funcname => 'TheSchwartz::Worker::SendEmail',
                                                arg      => $new_args,
                                                coalesce => "$dom\@",
                                                );
            push @new_jobs, $new_job;
        }
        $job->replace_with(@new_jobs);
        return;
    }

    # all rcpts on same server, proceed...
    my ($host, $rcpts) = %dom_rcpts;   # (there's only one key)
    $0 = "send-email [$host]";

    my @mailhosts = mx(resolver(), $host);

    my @ex = map { $_->exchange } @mailhosts;

    # seen in wild:  no MX records, but port 25 of domain is an SMTP server.  think it's in SMTP spec too?
    @ex = ($host) unless @ex;

    my $smtp = Net::SMTP::BetterConnecting->new(
                                                \@ex,
                                                Hello          => $hello_domain,
                                                PeerPort       => 25,
                                                ConnectTimeout => 4,
                                                );
    die "Connection failed to domain '$host', MXes: [@ex]\n" unless $smtp;

    $smtp->timeout(300);
    # FIXME: need to detect timeouts to log to errors, so people with ridiculous timeouts can see that's why we're not delivering mail

    my $done = 0;
    while ($job && $class->_send_job_on_connection($smtp, $job) && ++$done < 50) {
        my $job1 = $job;
        $job = $client->find_job_with_coalescing_prefix(__PACKAGE__, "$host\@");

        my $handle = '<nothing>';
        if ($job) {
            $job->set_as_current;
            $handle = $job->handle->as_string;
            die "RSET failed" unless $smtp->reset;
        }

        $job1->debug("sent successfully.  trying another.  found: " . $handle);
    }

    $smtp->quit;
}

sub _send_job_on_connection {
    my ($class, $smtp, $job) = @_;

    my $args = $job->arg;
    my $hstr = $job->handle->as_string;

    if ($ENV{DEBUG}) {
        use Data::Dumper;
        warn "sending email on $smtp: " . Dumper($args);
    }

    my $env_from = $args->{env_from};  # Envelope From
    my $rcpts    = $args->{rcpts};     # arrayref of recipients
    my $body     = $args->{data};
    my $headers;

    my ($this_domain) = $env_from =~ /\@(.+)/;

    # remove bcc
    $body =~ s/^(.+?\r?\n\r?\n)//s;
    $headers = $1;
    $headers =~ s/^bcc:.+\r?\n//mig;

    # unless they specified a message ID, let's prepend our own:
    unless ($headers =~ m!^message-id:.+!mi) {
        $headers = "Message-ID: <sch-$hstr\@$this_domain>\r\n" . $headers;
    }

    my $details = sub {
        return eval {
            $smtp->code . " " . $smtp->message;
        }
    };

    my $not_ok = sub {
        my $cmd = shift;
        if ($smtp->status == 5) {
            $job->permanent_failure("Permanent failure during $cmd phase to [@$rcpts]: " . $details->());
            return 0;  # let's not re-use this connection anymore.
        }
        die "Error during $cmd phase to [@$rcpts]: " . $details->() . "\n";
    };

    return $not_ok->("MAIL")     unless $smtp->mail($env_from);

    my $got_an_okay = 0;
    my %perm_fail;
    foreach my $rcpt (@$rcpts) {
        if ($smtp->to($rcpt)) {
            $got_an_okay = 1;
            next;
        }
        if ($smtp->status == 5) {
            $perm_fail{$rcpt} = 1;
            $class->on_5xx_rcpt($job, $rcpt, $details->());
            next;
        }
        die "Error during TO phase to [@$rcpts]: " . $details->() . "\n";
    }

    unless ($got_an_okay) {
        $job->permanent_failure("Permanent failure TO [@$rcpts]: " . $details->() . "\n");
        return 0;
    }

    # have to add a fake "Received: " line in here, otherwise some
    # stupid over-strict MTAs like bellsouth.net reject it thinking
    # it's spam that was sent directly (it was).  Called
    # "NoHopsNoAuth".
    my $mailid = $hstr;
    $mailid =~ s/-/00/;  # not sure if hyphen is allowed in
    my $date = _rfc2822_date(time());
    my $rcvd = qq{Received: from localhost (theschwartz [127.0.0.1])
                      by $this_domain (TheSchwartzMTA) with ESMTP id $mailid;
                      $date
                  };
    $rcvd =~ s/\s+$//;
    $rcvd =~ s/\n\s+/\r\n\t/g;
    $rcvd .= "\r\n";

    return $not_ok->("DATA")     unless $smtp->data;
    return $not_ok->("DATASEND") unless $smtp->datasend($rcvd . $headers . $body);
    return $not_ok->("DATAEND")  unless $smtp->dataend;

    $job->completed;
    return 1;
}

sub on_5xx_rcpt {
    my ($class, $job, $email, $details) = @_;
    $on_5xx->($email, $job, $details);

}

sub keep_exit_status_for {
    return 0 unless $keep_exit_status_for;
    return $keep_exit_status_for->() if ref $keep_exit_status_for eq "CODE";
    return $keep_exit_status_for;
}

sub grab_for { 500 }
sub max_retries { 5 * 24 }  # 5 days * 24 hours
sub retry_delay {
    my ($class, $fails) = @_;
    return ((5*60, 5*60, 15*60, 30*60)[$fails] || 3600);
}

# TODO:
sub on_job_is_done_forever {
    my ($class, $job) = @_;
    # .... run subref to, say, put in LJ db that this email is undeliverable
}

sub _rfc2822_date {
    my $time = shift;
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) =
        gmtime($time);
    my @days = qw(Sun Mon Tue Wed Thu Fri Sat Sun);
    my @mon  = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
    return sprintf("%s, %d %s %4d %02d:%02d:%02d +0000 (UTC)",
                   $days[$wday], $mday, $mon[$mon], $year+1900, $hour, $min, $sec);
}

package Net::SMTP::BetterConnecting;
use strict;
use base 'Net::SMTP';
use Net::Config;
use Net::Cmd;

# Net::SMTP's constructor could use improvement, so this is it:
#     -- retry hosts, even if they connect and say "4xx service too busy", etc.
#     -- let you specify different connect timeout vs. command timeout
sub new {
    my $self = shift;
    my $type = ref($self) || $self;
    my ($host, %arg);
    if (@_ % 2) {
        $host = shift;
        %arg  = @_;
    } else {
        %arg  = @_;
        $host = delete $arg{Host};
    }

    my $hosts = defined $host ? $host : $NetConfig{smtp_hosts};
    my $obj;
    my $timeout         = $arg{Timeout} || 120;
    my $connect_timeout = $arg{ConnectTimeout} || $timeout;

    my $h;
    foreach $h (@{ref($hosts) ? $hosts : [ $hosts ]}) {
        $obj = $type->IO::Socket::INET::new(PeerAddr => ($host = $h),
                                            PeerPort => $arg{Port} || 'smtp(25)',
                                            LocalAddr => $arg{LocalAddr},
                                            LocalPort => $arg{LocalPort},
                                            Proto    => 'tcp',
                                            Timeout  => $connect_timeout,
                                            )
            or next;

        $obj->timeout($timeout);  # restore the original timeout
        $obj->autoflush(1);
        $obj->debug(exists $arg{Debug} ? $arg{Debug} : undef);

        my $res = $obj->response();
        unless ($res == CMD_OK) {
            $obj->close();
            $obj = undef;
            next;
        }

        last if $obj;
    }

    return undef unless $obj;

    ${*$obj}{'net_smtp_exact_addr'} = $arg{ExactAddresses};
    ${*$obj}{'net_smtp_host'}       = $host;
    (${*$obj}{'net_smtp_banner'})   = $obj->message;
    (${*$obj}{'net_smtp_domain'})   = $obj->message =~ /\A\s*(\S+)/;

    unless ($obj->hello($arg{Hello} || "")) {
        $obj->close();
        return undef;
    }

    return $obj;
}
