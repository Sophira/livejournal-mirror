#!/usr/bin/perl
package LJ::Worker::PhonePostPoll;
use strict;
use lib "$ENV{LJHOME}/cgi-bin";
use base 'LJ::Worker::Manual';
require "ljlib.pl";
use IO::Socket::INET;

# return 1 if we did work, false if not.
sub work {
    my $class = shift;

    my $did_work = 0;
    foreach my $dst (@LJ::PHONEPOST_EDGE_HOSTS) {
        $did_work = 1 if poll_from_host($dst);
    }
    return $did_work;
}

my %sock_cache;  # "ip:port" => $sock
my %conn_time;   # "ip:port" => connect_unixtime
my %dead_until;  # "ip:port" => unixtime
sub poll_from_host {
    my $dst = shift;
    my $now = time();
    return 0 if $dead_until{$dst} && $dead_until{$dst} > $now;

    # re-connect every 30 seconds to make sure xinetd process
    # on other side gets re-execed if it changes.
    my $sock = $conn_time{$dst} > $now - 30 ? $sock_cache{$dst} : undef;

    # see if it disconnected?
    undef $sock if $sock && ! getpeername($sock);

    unless ($sock) {
        $sock_cache{$dst} = $sock = IO::Socket::INET->new(PeerAddr => $dst,
                                                          Timeout  => 5);
        $conn_time{$dst} = $now;
    }
    unless ($sock) {
        $dead_until{$dst} = $now + 30;
        return 0;
    }

    # FIXME: this whole thing is blocking and error-prone, because
    # network cable or host can get yanked at any time and hang this
    # process, and nothing's watch-dogging it.  and alarm() sucks.  I
    # want some ddlockd-style watchdog parent, which will kill
    # ourselves if we don't release our alarm request in time we
    # request.

    print $sock "LIST\n";
    my @files;
    while (my $line = <$sock>) {
        chomp $line;
        last if $line eq '.';
        push @files, $line;
    }

    return 0 unless @files;

    my $did_work = 0;
    foreach my $f (@files) {
        $did_work = 1 if grab_file($sock, $f);
    }

    return $did_work;
}

sub grab_file {
    my ($sock, $file) = @_;
    my $lockc = LJ::locker();
    my $lock = $lockc->trylock("phonepost-poll-$file")
        or return 0;

    print $sock "GET $file\n";

    # FIXME: actually put in Mogile

    my $on_data   = sub {};  # subref->($scalaref), called on data read

    my $qinfo;

    STATUS: while (my $status = <$sock>) {
        chomp $status;
        return 1 if $status eq ".";

        if ($status =~ m/^ERROR\s+/) {
            warn "$status\n";
            return 0;
        }
        elsif (my ($type, $orig_size) = $status =~ m/^(QINFO|WAV)\s+(\d+)$/i) {
            warn "receiving $type $file $orig_size\n";

            my $remain   = $orig_size;
            my $readsize = ($remain < 1024) ? $remain : 1024;

            if ($type eq "QINFO") {
                $on_data = sub {
                    my $dref = shift;
                    $qinfo .= $$dref;
                    print "read qinfo: [$qinfo]\n";
                };
            } elsif ($type eq "WAV") {
                $on_data = sub {
                    my $dref = shift;
                    # TODO: write into mogile

                    my $len = length($$dref);
                    print "read wav data on $len bytes....\n";

                    if ($remain == 0) {
                        # TODO: close mogile file, enqueue schwartz, etc.
                        # die if any problems.  otherwise this all returns 1.
                        # also delete the file if everything goes well.
                        print "Done with WAV!\n";
                    }
                };
            }

            READ: while ((my $readbytes = read( $sock, my $buf, $readsize )) != 0) {
                warn "Read, wanted $readsize, got $readbytes\n";

                $remain  -= $readbytes;
                $readsize = ($remain < 1024) ? $remain : 1024;

                $on_data->(\$buf);

                warn "Remaining: $remain\n";
                next READ   if $remain > 0;
                die "read too much?" if $remain < 0;
                next STATUS;
            }
            die "Connection unexpectedly closed\n";
        }

        die "Protocol error\n";
    }
    die "Connection unexpectedly closed\n";
}

__PACKAGE__->run;

