#!/usr/bin/perl
package LJ::Worker::PhonePostPoll;
use strict;
use lib "$ENV{LJHOME}/cgi-bin";
use base 'LJ::Worker::Manual';
require "ljlib.pl";
use IO::Socket::INET;

# return 1 if we did work, false if not.
sub work {
    my $class = shift;

    my $did_work = 0;
    foreach my $dst (@LJ::PHONEPOST_EDGE_HOSTS) {
        $did_work = 1 if poll_from_host($dst);
    }
    return $did_work;
}

my %sock_cache;  # "ip:port" => $sock
my %conn_time;   # "ip:port" => connect_unixtime
my %dead_until;  # "ip:port" => unixtime
sub poll_from_host {
    my $dst = shift;
    my $now = time();
    return 0 if $dead_until{$dst} && $dead_until{$dst} > $now;

    # re-connect every 30 seconds to make sure xinetd process
    # on other side gets re-execed if it changes.
    my $sock = $conn_time{$dst} > $now - 30 ? $sock_cache{$dst} : undef;

    # see if it disconnected?
    undef $sock if $sock && ! getpeername($sock);

    unless ($sock) {
        $sock_cache{$dst} = $sock = IO::Socket::INET->new(PeerAddr => $dst,
                                                          Timeout  => 5);
        $conn_time{$dst} = $now;
    }
    unless ($sock) {
        $dead_until{$dst} = $now + 30;
        return 0;
    }

    # FIXME: this whole thing is blocking and error-prone, because
    # network cable or host can get yanked at any time and hang this
    # process, and nothing's watch-dogging it.  and alarm() sucks.  I
    # want some ddlockd-style watchdog parent, which will kill
    # ourselves if we don't release our alarm request in time we
    # request.

    print $sock "LIST\n";
    my @files;
    while (my $line = <$sock>) {
        chomp $line;
        last if $line eq '.';
        push @files, $line;
    }

    return 0 unless @files;

    my $did_work = 0;
    foreach my $f (@files) {
        $did_work = 1 if grab_file($sock, $f);
    }

    return $did_work;
}

sub grab_file {
    my ($sock, $file) = @_;
    my $lockc = LJ::locker();
    my $lock = $lockc->trylock("phonepost-poll-$file")
        or return 0;

    print $sock "GET $file\n";

    # FIXME: actually put in Mogile

    my $on_data   = sub {};  # subref->($scalaref), called on data read

    my $qinfo;

    STATUS: while (my $status = <$sock>) {
        chomp $status;
        return 1 if $status eq ".";

        if ($status =~ m/^ERROR\s+/) {
            warn "$status\n";
            return 0;
        }
        elsif (my ($type, $orig_size) = $status =~ m/^(QINFO|WAV)\s+(\d+)$/i) {
            warn "receiving $type $file $orig_size\n";

            my $remain   = $orig_size;
            my $readsize = ($remain < 1024) ? $remain : 1024;

            if ($type eq "QINFO") {
                $on_data = sub {
                    my $dref = shift;
                    $qinfo .= $$dref;
                };
            } elsif ($type eq "WAV") {
                my $mogfh;
                my $mogkey;
                my $mogc = LJ::mogclient() or die "No mogile client.";

                $on_data = sub {
                    my $dref = shift;

                    unless ($mogfh) {
                        $mogkey = "phonepostwav:$file";
                        $mogfh = $mogc->new_file($mogkey, "", $orig_size)
                            or die "Failed to get new mogile filehandle";
                    }

                    my $len = length($$dref);
                    print $mogfh $$dref;

                    if ($remain == 0) {
                        # close mogile file, enqueue schwartz, etc.
                        # die if any problems.  otherwise this all returns 1.
                        # also delete the file if everything goes well.
                        unless (close($mogfh)) {
                            die "Failed to write to mogile: " . $mogc->errcode . ": " . $mogc->errstr;
                        }

                        my $sclient = LJ::theschwartz()
                            or die "No Schwartz client";

                        my $qparams = {};
                        while ($qinfo =~ s/^(.+): (.+)\r?\n//) {
                            $qparams->{$1} = $2;
                        }

                        my $job = TheSchwartz::Job->new_from_array("LJ::Worker::PhonePostProcess", {
                            mogkey => $mogkey,
                            qinfo  => $qparams,
                        });

                        my $h = $sclient->insert($job)
                            or die "Failed to insert into theschwartz";

                        # delete it
                        {
                            print $sock "DELETE $file\n";
                            my $line = <$sock>;
                            die "didn't get period response after delete" unless $line =~ /^\./;
                        }

                        return 1;
                    }
                };
            }

            if ($orig_size == 0) {
                $on_data->(\"");
                next STATUS;
            }

            READ: while ((my $readbytes = read( $sock, my $buf, $readsize )) != 0) {

                $remain  -= $readbytes;
                $readsize = ($remain < 1024) ? $remain : 1024;

                $on_data->(\$buf);

                next READ   if $remain > 0;
                die "read too much?" if $remain < 0;
                next STATUS;
            }
            die "Connection unexpectedly closed\n";
        }

        die "Protocol error\n";
    }
    die "Connection unexpectedly closed\n";
}

__PACKAGE__->run;

