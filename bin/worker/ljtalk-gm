#!/usr/bin/perl

use strict;
use lib "$ENV{LJHOME}/cgi-bin";
require 'ljprotocol.pl';
use LJ::Worker::Gearman;

gearman_decl("ljtalk_auth_check"  => \&ljtalk_auth_check);
gearman_decl("ljtalk_get_roster"  => \&ljtalk_get_roster);
gearman_decl("ljtalk_avatar_data" => \&ljtalk_avatar_data);
gearman_decl("ljtalk_avatar_sha1" => \&ljtalk_avatar_sha1);
gearman_decl("ljtalk_bot_talk"    => \&ljtalk_bot_talk);
gearman_work();

# ----------------------------------------------------------------------------

use Image::Magick;
use Digest::SHA1 qw(sha1_hex);
use Storable;

sub ljtalk_auth_check {
    my $job = shift;
    my $arg = $job->arg;
    return "BAD" unless $arg =~ /^(\w{1,50}),(\w+),(\w+)$/;
    my ($user, $streamid, $digest) = ($1, $2, $3);
    my $u = LJ::load_user($user)
        or return "ERR:nouser";
    return "ERR:notperson"  unless $u->{journaltype} eq "P";
    return "ERR:nopassword" unless $u->{password};
    my $correct = sha1_hex($streamid . $u->{password});
    return "ERR:badpass" unless $digest eq $correct;
    return "OK";
}

sub ljtalk_get_roster {
    my $job = shift;
    my $user = $job->arg;
    my $u = LJ::load_user($user) or die "No user";

    my %user;  # uid -> [$user, relation(1=pendout, 2=back)]
    my $dbr = LJ::get_db_reader();
    my $sth;

    # get outgoing friends
    $sth = $dbr->prepare("SELECT u.userid, u.user FROM user u, friends f ".
                         "WHERE f.userid=? AND f.friendid=u.userid AND u.journaltype='P'");
    die "db error" if $dbr->errstr;
    $sth->execute($u->{userid});
    while (my ($uid, $user) = $sth->fetchrow_array) {
        next if $uid == $u->{userid};
        $user{$uid} = [$user, 1];
    }

    # get edges back
    my $uids = join(',', keys %user);
    if ($uids) {
        $sth = $dbr->prepare("SELECT userid FROM friends WHERE friendid=? AND userid IN ($uids)");
        $sth->execute($u->{userid});
        while (my ($uid) = $sth->fetchrow_array) {
            my $erec = $user{$uid}      or next;
            $erec->[1] = 2;
        }
    }

    # list of [jid, nick, [@edges], [@groups]]
    my @list;
    foreach my $uid (sort { $user{$a}[0] cmp $user{$b}[0] } keys %user) {
        my $urec = $user{$uid};
        my @grp = ($LJ::SITENAMESHORT);
        my @edge;
        if ($urec->[1] == 2) {
            @edge = qw(to from);
        } else {
            @edge = qw(pending_out);
        }
        push @list, ["$urec->[0]\@$LJ::DOMAIN", $urec->[0], \@edge, \@grp];
    }

    return Storable::nfreeze(\@list);
}

sub ljtalk_avatar_data {
    return _avatar_want(shift, "data");
}

sub ljtalk_avatar_sha1 {
    return _avatar_want(shift, "sha1");
}

sub _avatar_want {
    my ($job, $want) = @_;
    my $u = LJ::load_user($job->arg) or die "invalid user: '" . $job->arg . "'";
    return "" unless $u->{defaultpicid};

    my $memkey = [$u->{userid}, "avatar:$u->{userid}:$u->{defaultpicid}"];

    my $res = sub {
        my $val = shift;      # [ [blobref, mime, w, h], sha1 ]
        return $val->[1] if $want eq "sha1";
        my $img     = $val->[0];
        my $blobref = $img->[0];
        my $mime    = $img->[1];
        return $$blobref;
    };

    my $val = LJ::MemCache::get($memkey);
    return $res->($val) if $val;

    # get image parameters ($imp) of [blobref, mime, w, h]
    my $imp = LJ::_get_upf_scaled(size   => 96,
                                  mogkey => $u->mogfs_userpic_key($u->{defaultpicid}));
    die "ERROR: could not resize image down\n" unless $imp;

    my $blobref = $imp->[0];
    my $sha1    = sha1_hex($$blobref);
    $val        = [$imp, $sha1];

    LJ::MemCache::set($memkey, $val, 86400);
    return $res->($val);
}

sub ljtalk_bot_talk {
    my $job = shift;
    my $req = Storable::thaw($job->arg);
    my $text = $req->{text} || "";
    my $ret = sub {
        return Storable::nfreeze({ text => $_[0], html => $_[1] });
    };

    unless ($text =~ m!^post:\s*(.+)!) {
        return $ret->("I don't know what that means.  I'm actually pretty stupid.  Start a message to me with 'post: ' and some text, and I'll post it to your journal.");
    }

    my $body = $1;
    # build lj entry
    my $props = {};
    my $req = {
        #'usejournal' => $journal,
        'ver' => 1,
        'username' => $req->{user},
        'event' => $body,
        'subject' => "Posted using LJTalk...",
        #'security' => $lj_headers{security},
        #'allowmask' => $amask,
        'props' => $props,
        'tz'    => 'guess',
    };

    # post!
    my $post_error;
    my $res = LJ::Protocol::do_request("postevent", $req, \$post_error, { noauth => 1 });
    if ($post_error) {
        return $ret->("Error: $post_error");
    }

    my $url = $res->{url};
    return $ret->("Posted: $url", "<i>Posted:</i> <a href='$url'>$url</a>");
}
