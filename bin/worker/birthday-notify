#!/usr/bin/perl

package LJ::Worker::BirthdayNotify;

use strict;
use lib "$ENV{LJHOME}/cgi-bin";
use base 'LJ::Worker::Manual';
use LJ::Event::Birthday;

# send out for notifications up to two days in the future
my $advance_notify = $LJ::BIRTHDAY_NOTIFS_ADVANCE || 2*86400; # 2 days

# delay for polling clusters that last had no users
my $delay_when_none = 15;

# how long to wait if we didn't process any at all
my $sleep_when_idle = 10;

# mapping of clusterid -> when they were last empty
my %last_empty;

sub work {
    my $class = shift;
    my @uids = @_;

    # pick a cluster to work on, get a lock
    my $lock;
    my $working_clusterid = 0;
    foreach my $cid (@LJ::CLUSTERS) {
        last if @uids;

        debug("Checking cluster: $cid");
        next unless cluster_needs_work($cid);

        $lock = LJ::locker()->trylock("birthday-notify:" . $cid);
        next unless $lock;

        # got a lock and a reader
        debug("Fetching users from cluster: $cid");
        push @uids, get_users_from_cluster($cid);

        # found a clusterid to work on!
        $working_clusterid = $cid;

        last;
    }

    # when we return 0 here, we'll be considered idle
    return 0 unless @uids;

    my $us = LJ::load_userids(@uids);
    my $ct = 0;

    foreach my $u (values %$us) {

        # if a user's been expunged, but their data is still on the cluster,
        # we want to enter a lazy-cleanup mode so we don't keep fetching users
        # we can't process
        if ($u->is_expunged) {
            debug("Cleaning up for expunged user: " . $u->user);

            my $dbcm = LJ::get_cluster_master($working_clusterid)
                or die "unable to connect to clusterid for cleanup: $working_clusterid";

            $dbcm->do("DELETE FROM birthdays WHERE userid=?", undef, $u->id);
            die $dbcm->errstr if $dbcm->err;

            # move on to valid foo's
            next;
        }

        # gotta do this before we run the setter!
        my $bday = $u->next_birthday;

        # gotta do this before we 'next' out (or else we risk
        # getting the same users). however, next out if the
        # setter failed (due to invalid birthday, most likely)
        $u->set_next_birthday or next;

        # don't mail if their birthday is over 24h ago (backlogged)
        next if $bday < time() - 24*60*60;

        next unless $u->is_person;
        next unless $u->is_visible;
        next unless $u->can_show_bday;

        debug("Firing off notification for $u->{user}");
        LJ::Event::Birthday->new($u)->fire;
        $ct++;
    }

    # return and release our lock as it falls out of scope

    return $ct;
}

sub on_idle {
    return sleep $sleep_when_idle;
}

sub debug {
    LJ::Worker::Manual->cond_debug(@_);
}


# checks if a cluster has pending notifications to send out.
sub cluster_needs_work {
    my $cluster = shift;

    # don't hammer a cluster if we don't have anyone on it.
    return if $last_empty{$cluster} && $last_empty{$cluster} < time() + $delay_when_none;

    # now check if there are pending notifications on the cluster
    my $dbcr = LJ::get_cluster_def_reader($cluster);
    return unless $dbcr;

    my $ct = $dbcr->selectrow_array("SELECT userid FROM birthdays WHERE " .
                                    "nextbirthday < UNIX_TIMESTAMP() + $advance_notify LIMIT 1")+0;
    die $dbcr->errstr if $dbcr->err;
    return 1 if $ct;

    # otherwise, we had nobody. make a note of that.
    $last_empty{$cluster} = time();
    return undef;
}

sub get_users_from_cluster {
    my $cluster = shift;

    my $dbcr = LJ::get_cluster_def_reader($cluster);
    die "Unable to get cluster reader for cluster $cluster" unless $dbcr;

    my $userids = $dbcr->selectcol_arrayref("SELECT userid FROM birthdays " .
                                            "WHERE nextbirthday < UNIX_TIMESTAMP() + $advance_notify LIMIT 1000");
    die $dbcr->errstr if $dbcr->err;

    return @$userids;
}


################################################################################

# to be able to work on one specific user
if (@ARGV) {
    my $user = shift;
    my $u = LJ::load_user($user);
    __PACKAGE__->work($u->id);
} else {
    __PACKAGE__->run();
}
