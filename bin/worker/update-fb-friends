#!/usr/bin/perl
use strict;
my @reexec;
BEGIN {
    @reexec = ($0, @ARGV);
}
use lib "$ENV{LJHOME}/cgi-bin";
require 'ljlib.pl';
use LJ::Worker::TheSchwartz;
use GTop ();
my $gtop = GTop->new;

# this process leaks memory.  this restarts it when it gets too big.
# this should be moved up into the base class.
schwartz_onidle(sub {
    my $proc_mem = $gtop->proc_mem($$);
    my $rss = $proc_mem->rss;
    my $good_size = 1024*1024 * 100; # 100 MB or less is tolerable
    return if $rss < $good_size;
    # restart ourselves, killing off the fat.
    exec @reexec;
});

schwartz_decl('LJ::Worker::UpdateFotobilderFriends');
schwartz_work();

############################################################################

package LJ::Worker::UpdateFotobilderFriends;
use base 'TheSchwartz::Worker';
use RPC::XML;
use RPC::XML::Client;

sub keep_exit_status_for { 0 }
sub grab_for { 60 }
sub max_retries { 500 }   # pretty much forever (500 days almost)
sub retry_delay {
    my ($class, $fails) = @_;
    return 86400 if $fails > 20;
    return 3600 if $fails > 7;
    return [15, 15, 30, 60, 120, 300, 900, 900]->[$fails];
}

sub work {
    my ($class, $job) = @_;
    my $uid = $job->arg;

    my $u = LJ::load_userid($uid)
        or die "no userid";
    my %req = ( user => $u->{user} );

    # find all equivalent jobs BEFORE we do the potentially slow /
    # blocky XML-RPC request.  this way if new invalidations come in
    # while we're working, we don't invalidate those.  which is also
    # why we don't use TheSchwartz's 'unique' feature and do it by
    # hand like this.... afterwards we'll mark these found jobs as
    # completed.
    my $client = $job->handle->client;
    my @others = $client->list_jobs({
        funcname => $class,
        coalesce => "uid:$uid",
        limit => 100000,  # some journals update their friends a ton, scripted.  find all dups.
    });

    # fill in groups info
    LJ::fill_groups_xmlrpc($u, \%req);

    my $res = RPC::XML::Client
        ->new("$LJ::FB_SITEROOT/interface/xmlrpc")
        ->send_request('FB.XMLRPC.groups_push',
                       # FIXME: don't be lazy with the smart_encode
                       RPC::XML::smart_encode(\%req));

    # weirdest calling conventions evar.
    die "No response from client" unless $res;
    die "Error response (local): $res" unless ref $res;
    die "Error response from other party: code=" . ${$res->{faultCode}} . " string=" . ${$res->{faultString}} if
        UNIVERSAL::isa($res, "RPC::XML::fault");

    # after all that, should have worked, so close this job and all others
    # that existed prior
    my $main_handle = $job->handle->as_string;
    $job->completed;
    foreach my $j (@others) {
        next if $j->handle->as_string eq $main_handle;
        $j->completed;
    }
}

