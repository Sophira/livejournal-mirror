#!/usr/bin/perl
use strict;
use lib "$ENV{LJHOME}/cgi-bin";
require 'ljlib.pl';
use LJ::Worker::TheSchwartz;

LJ::Worker::TheSchwartz->set_memory_limit(1024 * 1024 * 100); # 100MB memory limit.

schwartz_decl('LJ::Worker::UpdateFotobilderFriends');
schwartz_work();

############################################################################

package LJ::Worker::UpdateFotobilderFriends;
use base 'TheSchwartz::Worker';
require 'ljlib.pl';
require 'fotobilder.pl';
use FB::SecGroup;
use FB::User;

die "FB::LJ_DOMAINID must be defined." unless defined $FB::LJ_DOMAINID;

sub keep_exit_status_for { 0 }
sub grab_for { 60 }
sub max_retries { 500 }   # pretty much forever (500 days almost)
sub retry_delay {
    my ($class, $fails) = @_;
    return 86400 if $fails > 20;
    return 3600 if $fails > 7;
    return [15, 15, 30, 60, 120, 300, 900, 900]->[$fails];
}

sub work {
    my ($class, $job) = @_;

    my $uid = $job->arg + 0
        or die "No userid";

    my $u = LJ::load_userid($uid)
        or die "Error loading userid $uid";

    # fotobilder won't autovivify communities/shared, so it won't accept
    # friends update pushes.
    if ($u->is_community || $u->is_shared) {
        $job->completed;
        return;
    }

    # find all equivalent jobs BEFORE we do the update.  this way if
    # new invalidations come in while we're working, we don't
    # invalidate those.  which is also why we don't use TheSchwartz's
    # 'unique' feature and do it by hand like this.... afterwards
    # we'll mark these found jobs as completed.
    my $client = $job->handle->client;
    my @others = $client->list_jobs({
        funcname => $class,
        coalesce => "uid:$uid",
        limit => 100000,  # some journals update their friends a ton, scripted.  find all dups.
    });

    my $lj_groups = LJ::get_friend_group($u)
        or die "could not get LJ friend groups for FB userid $uid";

    # 30 possible lj groups + 1 magical group that contains everyone
    # bits 0-30 => secids 126-157
    my $get_secid = sub {
        my $offset = $_[0]+0;

        # - 126 is base secid for authmod group range
        # - offset is actual bit number of this group on remote LJ site
        return 126 + $offset;
    };

    my %update; # params to update_secgroup_multi
                # takes { secid => [grpname, [memberid1, memberid2, ...]] }

    # group 126 is all LJ friends
    my $friends = LJ::get_friends($u);
    $update{126} = ["LJ:all_friends", [keys %$friends]];

    foreach my $lj_secbit (keys %$lj_groups) {
        # get group members
        my $group_members = LJ::get_friends($u, $lj_secbit);
        my @group_uids = keys %$group_members;

        # convert lj secbit to fb secid
        my $fb_secid = $get_secid->($lj_secbit);

        my $groupname = 'LJ:' . $lj_groups->{$lj_secbit}->{groupname};

        $update{$fb_secid} = [$groupname, [@group_uids]];
    }

    # vivify FB user if necessary
    my $fb_uid;

    unless ($u->fb_u) {
        $fb_uid = FB::User->create({
            'domainid' => $FB::LJ_DOMAINID,
            'usercs'   => $u->user,
            'r_userid' => $u->id, # remote userid
        }) or die "error in create user: $@";
    } else {
        $fb_uid = $u->fb_u->id;
    }

    FB::update_secgroup_multi($u->fb_u, \%update)
        or die "error in update_secgroup_multi: $@";

    # after all that, should have worked, so close this job and all others
    # that existed prior
    my $main_handle = $job->handle->as_string;
    $job->completed;
    foreach my $j (@others) {
        next if $j->handle->as_string eq $main_handle;
        $j->completed;
    }
}

