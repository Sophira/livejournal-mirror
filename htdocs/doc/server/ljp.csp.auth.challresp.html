<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>3. Challenge / Response</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.55.0"><link rel="home" href="index.html" title="LiveJournal Server"><link rel="up" href="ljp.csp.auth.html" title="Chapter 9. Authentication in the Client Server Protocol"><link rel="previous" href="ljp.csp.auth.cookies.html" title="2. HTTP Cookies"><link rel="next" href="ljp.csp.flat.protocol.html" title="Flat Client/Server Protocol Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. Challenge / Response</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ljp.csp.auth.cookies.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Authentication in the Client Server Protocol</th><td width="20%" align="right"> <a accesskey="n" href="ljp.csp.flat.protocol.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a class="linkhere" href="#ljp.csp.auth.challresp">»</a><a name="ljp.csp.auth.challresp"></a>3. Challenge / Response</h2></div></div><p>Another way to authenticate your client is to build a hex digest consisting of the user's password and
      a challenge as issued by the server. This is currently known as <i><tt>auth_method</tt></i> &#8220;challenge&#8221;.</p><p>Essentially, you generate a challenge by issuing a blank request to the <tt>getchallenge</tt> method. If your
      method call is successful you're given:</p><div class="variablelist"><dl><dt><span class="term">string auth_scheme</span></dt><dd>You can ignore this for now. By default this is the highest version of our
            authentication schemes, if in the future if we implement other auth schemes or change the default.
            In that case we'd add a new capabilities exchange: your client could say, &quot;I know c0 and c1&quot;, and
            our server would then say, &quot;Use c1, it's the best.&quot;</dd><dt><span class="term">string challenge</span></dt><dd>challenge is an opaque cookie, as generated by
          ???. Challenges may only be used once.</dd><dt><span class="term">int expire_time</span></dt><dd>expire_time is the expiration time for the challenge
          as measured in seconds since the Unix epoch.</dd><dt><span class="term">int server_time</span></dt><dd>servertime is the time of when the challenge was generated,
            as measured in seconds since the Unix epoch. The formula (server_time -
          expire_time) is the life span of the challenge, in seconds.</dd></dl></div><p>For your response, you then build a MD5 hex digest of the formula (challenge
      + MD5_hex(<tt>password</tt>)). To authenticate your client now, you simply send back the following 3
      parameters, along with your username:</p><div class="variablelist"><dl><dt><span class="term">string <i><tt>auth_method</tt></i></span></dt><dd>Set to &#8216;challenge&#8217;</dd><dt><span class="term">string <i><tt>auth_challenge</tt></i></span></dt><dd>The challenge issued by the server</dd><dt><span class="term">string <i><tt>auth_response</tt></i></span></dt><dd>MD5_hex(challenge + MD5_hex(<tt>password</tt>))</dd></dl></div><div class="example"><p class="title"><b>Example 9.2. Sample Perl script using <tt>getchallenge</tt></b></p><pre class="programlisting">
use strict;
use Fcntl;
use XMLRPC::Lite;
use Data::Dumper;
use Digest::MD5 qw(md5_hex);

my $xmlrpc = new XMLRPC::Lite;
$xmlrpc-&gt;proxy(&quot;http://www.lj.com/interface/xmlrpc&quot;);
my $get_chal = xmlrpc_call(&quot;LJ.XMLRPC.getchallenge&quot;);
my $chal = $get_chal-&gt;{'challenge'};

my $user = &quot;test&quot;;
my $pass = &quot;pass&quot;;
print &quot;chal: $chal\n&quot;;

my $response = md5_hex($chal . md5_hex($pass));

my $login = xmlrpc_call('LJ.XMLRPC.login', {
        'username' =&gt; $user,
        'auth_method' =&gt; 'challenge',
        'auth_challenge' =&gt; $chal,
        'auth_response' =&gt; $response,
});

print Dumper($login);

sub xmlrpc_call {
    my ($method, $req) = @_;
    my $res = $xmlrpc-&gt;call($method, $req);
    if ($res-&gt;fault) {
        print STDERR &quot;Error:\n&quot;.
        &quot; String: &quot; . $res-&gt;faultstring . &quot;\n&quot; .
        &quot; Code: &quot; . $res-&gt;faultcode . &quot;\n&quot;;
        exit 1;
    }
    return $res-&gt;result;
}
      </pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ljp.csp.auth.cookies.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ljp.csp.auth.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ljp.csp.flat.protocol.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2. HTTP Cookies </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Flat Client/Server Protocol Reference</td></tr></table></div></body></html>
