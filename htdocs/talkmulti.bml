<?_code
{
    use strict;
    use vars qw(%POST $title $body);
    
    ## this page is called as endpoint from users journals, 
    ## so language scope must be set explicitly
    BML::set_language_scope('/talkmulti.bml');
    
    my $err = sub {
        my $errmsg = shift;
        $body = "<?h1 $ML{'Error'} h1?><?p $errmsg p?>";
        return;
    };

    my $mode = $POST{'mode'};
    if ($mode eq 'screen') {
        $title = $ML{'.title.screen'};
    } elsif ($mode eq 'unscreen') {
        $title = $ML{'.title.unscreen'};
    } elsif ($mode eq 'all:screen') {
        $title = $ML{'.title.all.screen'};
    } elsif ($mode eq 'all:unscreen') {
        $title = $ML{'.title.all.unscreen'};
    } elsif ($mode eq 'delete' || $mode eq 'deletespam') {
        $title = $ML{'.title.delete'};
    } elsif ($mode eq 'all:deletespam') {
        $title = $ML{'.title.all.delete'};
    } elsif ($mode eq 'unspam') {
        $title = $ML{'.title.unspam'};
    } elsif ($mode eq 'all:unspam') {
        $title = $ML{'.title.all.unspam'};
    } else {
        $title = $ML{'Error'};
        return $err->($ML{'.error.invalid_mode'});
    }

    my $sth;
   
    my $remote = LJ::get_remote();
    return $err->($ML{'.error.login'}) unless $remote;
    return $err->("<?requirepost?>") unless LJ::did_post();

    my $u = LJ::load_user($POST{'journal'});
    return $err->($ML{'talk.error.bogusargs'}) unless $u && $u->{'clusterid'};
    return $err->($LJ::MSG_READONLY_USER) if LJ::get_cap($u, "readonly");

    my $dbcr = LJ::get_cluster_def_reader($u);

    my $jid = $u->{'userid'};
    my $ditemid = $POST{'ditemid'}+0;
    my $itemid = int($ditemid / 256);

    my @talkids;
    if ($mode eq 'all:screen' or $mode eq 'all:unscreen' or $mode eq 'all:unspam' or $mode eq 'all:deletespam') {
        my $comments = LJ::Talk::get_talk_data($u, 'L', $itemid);
        @talkids = keys %$comments;
    } else {
        foreach (keys %POST) {
            push @talkids, $1 if /^selected_(\d+)$/;
        }
    }
    return $err->($ML{'.error.none_selected'}) unless @talkids;

    # here 'all' cases are same as 'selected'
    $mode = 'screen' if $mode eq 'all:screen';
    $mode = 'unscreen' if $mode eq 'all:unscreen';
    $mode = 'unspam' if $mode eq 'all:unspam';
    if ($mode eq 'all:deletespam') {
        $mode = 'deletespam';
        $POST{returnto} =~ s/mode=showspam//;
        $POST{returnto} =~ s/[\?\&]$//;
    }

    my $log = $dbcr->selectrow_hashref("SELECT * FROM log2 WHERE journalid=? AND jitemid=?",
                                       undef, $jid, $itemid);
    return $err->($ML{'.error.inconsistent_data'}) unless $log && $log->{'anum'} == ($ditemid & 255);
    my $up = LJ::load_userid($log->{'posterid'});

    # check permissions
    return $err->($ML{'.error.privs.screen'})
        if $mode eq "screen" && ! LJ::Talk::can_screen($remote, $u, $up);
    return $err->($ML{'.error.privs.unscreen'})
        if $mode eq "unscreen" && ! LJ::Talk::can_unscreen($remote, $u, $up);
    return $err->($ML{'.error.privs.delete'})
        if $mode eq "delete" && ! LJ::Talk::can_delete($remote, $u, $up);
    return $err->($ML{'.error.privs.delete'})
        if $mode eq 'deletespam' && ! LJ::Talk::can_mark_spam($remote, $u, $up);

    # filter our talkids down to those that are actually attached to the log2
    # specified.  also, learn the state and poster of all the items.
    my $in = join (',', @talkids);
    $sth = $dbcr->prepare("SELECT jtalkid, state, posterid FROM talk2 ".
                          "WHERE journalid=? AND jtalkid IN ($in) ".
                          "AND nodetype='L' AND nodeid=?");
    $sth->execute($jid, $itemid);
    my %talkinfo;
    while (my ($id, $state, $posterid) = $sth->fetchrow_array) {
        $talkinfo{$id} = [ $state, $posterid ];
    }
    @talkids = keys %talkinfo;

    # do the work:
    if ($mode eq "delete" || $mode eq 'deletespam') {
        # first, unscreen everything for replycount and hasscreened to adjust
        my @unscreen = grep { $talkinfo{$_}->[0] eq "S" } @talkids;
        LJ::Talk::unscreen_comment($u, $itemid, @unscreen);
        # FIXME: race condition here... somebody could get lucky and view items while unscreened.
        # then delete, updating the log2 replycount as necessary

        # Mark as spam
        if ($mode eq 'deletespam') {
            # don't let $remote mark their own comments as spam
            my @new_talkids;
            foreach (grep { $talkinfo{$_}->[0] eq 'B' && $talkinfo{$_}->[1] != $remote->id } @talkids) {
                my $poster = LJ::want_user($talkinfo{$_}->[1]);
                next if LJ::Talk::can_mark_spam($poster, $u);
                push @new_talkids, $_;
                LJ::Talk::mark_comment_as_spam($u, $poster);
                LJ::Talk::delete_author( $u, $itemid, $poster->userid );
                LJ::set_rel($u, $poster, 'D');
                $u->ban_user($poster);
                $u->log_event('spam_set', { actiontarget => $poster->id, remote => $remote });
            }
            @talkids = @new_talkids;
        }

        my ($num, $numspam) = LJ::delete_comments($u, "L", $itemid, @talkids);
        LJ::replycount_do($u, $itemid, "decr", $num);
        LJ::replyspamcount_do($u, $itemid, "decr", $numspam);
        LJ::Talk::update_commentalter($u, $itemid);

    } elsif ($mode eq "unscreen") {
        LJ::Talk::unscreen_comment($u, $itemid, @talkids);

    } elsif ($mode eq "screen") {
        LJ::Talk::screen_comment($u, $itemid, @talkids);
    } elsif ($mode eq "unspam") {
         LJ::Talk::unspam_comment($u, $itemid, @talkids);
    }

    return BML::redirect($POST{returnto});
}
_code?>
<?page
title=><?_code return $title; _code?>
body=><?_code return $body; _code?>
page?><?_c <LJDEP>
</LJDEP> _c?>
