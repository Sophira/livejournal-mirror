<?page
body<=
<?_code
{
    use strict;
    use vars qw (%POST %GET $body $title $headextra);
    use Carp qw(croak);

    $title = BML::ml('.title');

    use Class::Autouse qw(LJ::NotificationMethod LJ::Event);

    my @errors;

    my $remote = LJ::get_remote();
    return "<?needlogin?>" unless $remote;

    return "Not ready" unless $remote->can_use_esn;

    my $formauth = LJ::form_auth();

    # set up default subscriptions for users that have not managed ESN stuff
    # do this for remote only, not authas users
    if (! $remote->prop('esn_has_managed') && ! $remote->subscription_count) {
        $remote->set_prop('esn_has_managed', 1);

        my @default_subscriptions = (
                                     LJ::Subscription::Pending->new($remote,
                                                                    event     => 'OfficialPost',
                                                                    ),
                                     );

                                     if ($remote->prop('opt_gettalkemail') ne 'N') {
                                         push @default_subscriptions, (
                                                                       LJ::Subscription::Pending->new($remote,
                                                                                                      event     => 'JournalNewComment',
                                                                                                      journal   => $remote,
                                                                                                      method    => 'Inbox',
                                                                                                      ),

                                                                       LJ::Subscription::Pending->new($remote,
                                                                                                      event     => 'JournalNewComment',
                                                                                                      journal   => $remote,
                                                                                                      method    => 'Email',
                                                                                                      ),
                                                                       );
                                     }

        $_->commit foreach @default_subscriptions;
    }

    # handle input
    if (LJ::did_post()) {
        return LJ::error_list(BML::ml('error.invalidform')) unless LJ::check_form_auth();

        # do they want to add or edit subscriptions?
        next unless $POST{mode} eq 'save_subscriptions';

        my @sub_edit;
        my @to_consider;

        foreach my $postkey (keys %POST) {
            my $subscr;
            my $old_postkey = $postkey;
            my $old = $postkey =~ /-old$/;

            # are there other options for this pending subscription? if so, process those not this one
            next if $postkey =~ /\.arg\d/;

            $subscr = LJ::Subscription->thaw($postkey, $remote, \%POST);

            next unless $subscr;

            if ($subscr->pending) {
                # don't duplicate subscriptions
                next if $remote->has_subscription($subscr->sub_info);

                my @inbox_subs = grep { $_->active && $_->enabled } $remote->find_subscriptions(method => 'Inbox');

                if ((scalar @inbox_subs) >= $remote->get_cap('subscriptions') && $subscr->method eq 'LJ::NotificationMethod::Inbox') {
                    push @errors, LJ::errobj("Subscription::TooMany", subscr => $subscr, u => $remote);
                } else {
                    # save this for consideration after we've processed all inbox subscriptions first
                    if ($subscr->method ne 'LJ::NotificationMethod::Inbox') {
                        push @to_consider, $subscr;
                    } else {
                        $subscr->commit;
                    }
                }
                next;
            } else {
                # this sub exists, make sure it's now activated
                $subscr->activate if $subscr->method eq 'LJ::NotificationMethod::Inbox' && $POST{$postkey} && !$old;
            }

            # remove old string
            $postkey =~ s/-old// if $old;

            next unless $old;

            my $oldvalue = $POST{$old_postkey};
            my $checked = $POST{$postkey};

            push @sub_edit, [
                             $subscr,
                             $checked,
                             $oldvalue,
                             ];
        }

        foreach my $edit_info (@sub_edit) {
            my ($subscr, $checked, $oldvalue) = @$edit_info;

            if (! $checked && $oldvalue) {
                # if it's not checked and is currently a real subscription, deactivate it
                $subscr->deactivate;
            }
        }

        foreach my $subscr (@to_consider) {
            # don't save a subscription if there is no corresponding inbox sub for it
            my %inbox_sub_params = $subscr->sub_info;
            $inbox_sub_params{ntypeid} = LJ::NotificationMethod::Inbox->ntypeid;
            delete $inbox_sub_params{flags};

            my ($inbox_sub) = $remote->has_subscription(%inbox_sub_params);

            $subscr->commit if $inbox_sub && $inbox_sub->active && $inbox_sub->enabled;
        }

        delete $remote->{_subscriptions};
    }

    # look for deletions from GET
    foreach my $subscr ($remote->subscriptions) {
        my $id = $subscr->id;
        next unless $id;

        if ($GET{"deletesub_$id"}) {
            $subscr->delete;
        }
    }

    $body .= "<?p" . LJ::error_list(@errors) . "p?>" if scalar @errors;

    ###################### Print subscribe table
    my @categories = (
                      {
                          "My Account" => [
                                           LJ::Subscription::Pending->new($remote,
                                                                          event     => 'OfficialPost',
                                                                          ),
                                           LJ::Subscription::Pending->new($remote,
                                                                          event     => 'JournalNewComment',
                                                                          journal   => $remote,
                                                                          ),
                                           'Befriended',
                                           ],
                          },
                      {
                          "Friends and Communities" => [
                                                        'InvitedFriendJoins',
                                                        'CommunityInvite',
                                                        'CommunityJoinRequest',
                                                        LJ::Subscription::Pending->new($remote,
                                                                                       event     => 'NewUserpic',
                                                                                       ),
                                                        ],
                          },
                      );

    $body .= qq {
        <div class="Blurb">"Manage your message settings and notices below. These settings
enable you to receive notifications from LiveJournal regarding
activity with your journal, friends, and communities.  Notifications
for 'My Account' and 'Friends and Communities' are not included in the
account limits.</div>
    };

    $body .= LJ::subscribe_interface($remote,
                                     journal      => $remote,
                                     categories   => \@categories,
                                     formauth     => $formauth,
                                     showtracking => 1,
                                     );

    return $body;
}
_code?>
<=body
title=><?_code return $title; _code?>
head<=
<?_code return $headextra; _code?>
<=head
<=body
page?>
