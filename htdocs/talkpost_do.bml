<?page
title=><?_code return $FORM{'submitpreview'} ? $ML{'.title.preview'} : $ML{'.title'}; _code?>
body<=

<?_code
{
    use strict;
    use vars qw(%FORM %ML);

    my $req = shift;
    my $r = $req->{'r'};

    foreach my $re (@LJ::TALKSPAM) {
        return if ($FORM{'body'} =~ /$re/);
    }

    return LJ::server_down_html() if $LJ::SERVER_DOWN;

    # normally require POST.  if an ecphash is specified, we'll let
    # them through since they're coming from a comment page and
    # validate the hash later.
    return "Comment not posted: POST required, or missing parameter." unless LJ::did_post() || $FORM{'ecphash'};

    # as an exception, we do NOT call LJ::text_in() to check for bad
    # input, since it may be not in UTF-8 in replies coming from mail
    # clients. We call it later.

    my $remote = LJ::get_remote();

    ## init.  this handles all the error-checking, as well.
    my @errors;
    my $init = LJ::Talk::Post::init(\%FORM, $remote, \@errors);
    return LJ::bad_input(@errors) unless $init;

    my $talkurl = $init->{talkurl};

    my $entryu   = $init->{entryu};
    my $journalu = $init->{journalu};
    my $parent   = $init->{parent};
    my $comment  = $init->{comment};
    my $item     = $init->{item};

    ## preview
    if ($FORM{'submitpreview'}) {
        return LJ::Talk::Post::make_preview($talkurl, $init->{cookie_auth}, \%FORM);
    }

    ## insertion
    my $wasscreened = ($parent->{state} eq 'S');
    my $err;
    unless (LJ::Talk::Post::post_comment($entryu, $journalu,
                                         $comment, $parent, $item, \$err)) {
        return $err;
    }

    # Yeah, we're done.
    my $dtalkid = $comment->{talkid}*256 + $item->{anum};
    my $commentlink = LJ::Talk::talkargs($talkurl, "view=$dtalkid#t$dtalkid");

    my $ret = "";
    $ret .= "<?h1 $ML{'.success.title'} h1?>";

    my $mlcode;
    if ($comment->{state} eq 'A') {
        $mlcode = '.success.message';
    } else {
        # otherwise, it's a screened comment.
        if ($journalu->{'journaltype'} eq 'C') {
            $mlcode = $FORM{'usertype'} eq 'anonymous' ? '.success.screened.comm.anon'
                                                       : '.success.screened.comm';
        } else {
            $mlcode = $FORM{'usertype'} eq 'anonymous' ? '.success.screened.user.anon'
                                                       : '.success.screened.user';
        }
    }

    $ret .= "<?p " . BML::ml($mlcode, { 'link' => $commentlink }) . " p?>";

    # did this comment unscreen its parent?
    if ($wasscreened and $parent->{state} ne 'S') {
        $ret .= "<?p $ML{'.success.unscreened'} p?>";
    }

    if ($init->{didlogin}) {
        $ret .= "<?p $ML{'.success.loggedin'} p?>";
    }

    return $ret;
}
_code?>

<=body
page?><?_c <LJDEP>
lib: LJ::SpellCheck
link: htdocs/lostinfo.bml, htdocs/userinfo.bml, htdocs/talkread.bml, htdocs/editinfo.bml
post: htdocs/talkpost_do.bml
</LJDEP> _c?>
