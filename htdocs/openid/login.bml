<?_code
{

    return "OpenID consumer support is disabled" unless $LJ::OPENID_CONSUMER;

    use strict;
    use vars qw($title $head $body %GET %POST);
    use Net::OpenID::Consumer;
    LJ::set_active_crumb("openid_login");

    $title = "OpenID Login";
    $head = "";

    my $err = sub {
        $title = "Error";
        $body = shift;
        return;
    };

    my $remote = LJ::get_remote();
    if ($remote) {
        $body .= "<?h1 Already logged in h1?><?p Hello, " . LJ::ljuser($remote) . ". Before logging in with <a href='http://www.danga.com/openid/'>OpenID</a>, you must first <a href='/logout.bml'>log out</a>. p?>";
        return;
    }

    my $get_csr = sub {
        require LWPx::ParanoidAgent;
        my $ua = LWPx::ParanoidAgent->new(
                                          timeout => 10,
                                          max_size => 1024*300,
                                          );

        my $csr = Net::OpenID::Consumer->new(
                                             ua => $ua,
                                             args => \%GET,
                                             cache => eval { LJ::MemCache::get_memcache() },
                                             );
        return $csr;
    };

    if ($GET{'openid.mode'}) {
        my $csr = $get_csr->();
        if (my $setup = $csr->user_setup_url) {
            return BML::redirect($setup);
        }

        my $vident = eval { $csr->verified_identity; };
        return $err->($csr->err) unless $vident;

        my $url = $vident->url;
        return $err->("Invalid characters in identity URL.") if $url =~ /[\<\>\s]/;

        my $u = LJ::User::load_identity_user("O", $url, $vident);
        return $err->("Couldn't vivify your account (but we verified that you're " . LJ::ehtml($url) . ")") unless $u;

        my $sess_opts = {
            'exptype' => 'short',
            'ipfixed' => 0,
        };
        my $etime = 0;
        if ($POST{'expire'} eq "never") {
            $etime = time()+60*60*24*60;
            $sess_opts->{'exptype'} = "long";
        }

        my $sess = $u->generate_session($sess_opts);
        my $cursess = $sess;
        my @sopts;
        LJ::run_hooks("login_add_opts", { 'u' => $u, 'form' => \%POST, 'opts' => \@sopts });
        my $sopts = @sopts ? ":" . join('', map { ".$_" } @sopts) : "";
        $COOKIE{'ljsession'} = [  "ws:$u->{'user'}:$sess->{'sessid'}:$sess->{'auth'}$sopts", $etime, 1 ]; # 1 => HttpOnly

        eval { Apache->request->notes('ljuser' => $u->{user}); };
        LJ::set_remote($u);

        return BML::redirect("$LJ::SITEROOT/login.bml");
    }


    if (LJ::did_post()) {
        my $csr = $get_csr->();
        my $url = $POST{'openid_url'};
        return $err->("Invalid characters in identity URL.") if $url =~ /[\<\>\s]/;

        my $tried_local_id = 0;
        $csr->ua->blocked_hosts(
                           sub {
                               my $dest = shift;
                               if ($dest =~ /livejournal\.com$/i) {
                                   $tried_local_id = 1;
                                   return 1;
                               }
                               return 0;
                           });

        my $claimed_id = $csr->claimed_identity($url);

        unless ($claimed_id) {
            return $err->("You can't use a LiveJournal OpenID account on LiveJournal &mdash; ".
                          "just <a href='/login.bml'>go login</a> with your actual LiveJournal account.") if $tried_local_id;
            return $err->($csr->err);
        }

        my $check_url = $claimed_id->check_url(
                                               return_to => "$LJ::SITEROOT/openid/login.bml",
                                               trust_root => "$LJ::SITEROOT/",
                                               delayed_return => 1,
                                               );
        return BML::redirect($check_url);
    }

return undef;

}
 _code?><?_info
nocache=>1
_info?><?page
title=><?_code return $title; _code?>
body=><?_code return $body; _code?>
page?>
