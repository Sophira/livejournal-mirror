<?page
title=>User Log Viewer
head<=
<style>
<!--
td.logrow {
    border: solid 1px rgb(230,230,230);
    padding: 2px;
    margin: 0px;
}
th.logrow {
    border: solid 1px rgb(180,180,180);
    padding: 2px;
    margin: 0px;
    text-weight: bold;
}
-->
</style>
<=head
body<=
<?_code
{
    use strict;
    use LJ::TimeUtil;

    use vars qw($GET $POST);

    my $remote = LJ::get_remote();
    return "<?needlogin?>" unless $remote;

    my $err = sub {
        return "<?h1 Error h1?><?p $_[0] p?>";
    };
    my $can_view =  LJ::check_priv($remote, 'canview', '*') || 
                    LJ::check_priv($remote, 'canview', 'userlog');
    my $can_view_uniq = LJ::check_priv($remote, 'canview', 'uniq');
    return $err->("You do not have the necessary privilege to view this page.")
        unless $can_view || 
                LJ::check_priv($remote, 'canview', 'userloglight') ||
                $LJ::IS_DEV_SERVER;

    my $user = LJ::canonical_username($POST{user} || $GET{user});

    my $ret = <<FORM;
<form method='post' action='userlog.bml'>
Username: <input type='text' name='user' value='$user' maxlength='15' size='15' /> <input type='submit' value='View' />
</form>
FORM
    return $ret unless $user;

    my $u = LJ::load_user($user);
    return $err->("User does not exist.")
        unless $u;

    return $err->("User is deleted and purged.")
        if $u->statusvis eq "X";

    my $dbcr = LJ::get_cluster_reader($u);
    return $err->("Unable to get user cluster reader.")
        unless $dbcr;

    my $sth = $dbcr->prepare('SELECT * FROM userlog WHERE userid = ? ORDER BY logtime DESC LIMIT 10000');
    $sth->execute($u->{userid});
    return $err->("Database error: " . $sth->errstr)
        if $sth->err;

    $ret .= "<?p Latest log entries for " . LJ::ljuser($u) . ". p?>";
    $ret .= "<table style='border: solid 1px black; width: 95%;'>\n";
    $ret .= "<tr>";
    $ret .= join('', map { "<th class='logrow'>$_</th>" } ("Date and Time", "Action", "Initiator", "IP Address", "Uniq Cookie"));
    $ret .= "</tr>\n";

    my $format_email = sub {
        my ($email) = @_;

        my $cmd = LJ::eurl("finduser $email");
        return qq{
            <a href="$LJ::SITEROOT/admin/console?prefill=$cmd">$email</a>
        };
    };

    # Hack, to display account_create event on last log row.
    # logtime field in userlog table has type int(10) unsigned and
    # events occured in less than one second after account creation
    # can occasionaly be displayed before it in user log.
    my $account_creation;
    while (my $row = $sth->fetchrow_hashref || $account_creation) {
        my $extra = {};
        LJ::decode_url_string($row->{extra}, $extra);

        my $action = "Action undefined for: $row->{action}";
        if ($row->{action} eq 'delete_entry') {
            $action = "Deleted entry $row->{actiontarget} via $extra->{method}";
        } elsif ($row->{action} eq 'delete_delayed_entry') {
            $action = "Deleted delayed entry $row->{actiontarget} via $extra->{method}";
        } elsif ($row->{action} eq 'account_create') {
            $action = "Account created";
            unless ( $account_creation ) {
                $account_creation = $row;
                next;
            }
        } elsif ($row->{action} eq 'ban_set') {
            my $u = LJ::load_userid($row->{actiontarget});
            $action = "Banned " . LJ::ljuser($u) if $u;
        } elsif ($row->{action} eq 'ban_unset') {
            my $u = LJ::load_userid($row->{actiontarget});
            $action = "Unbanned " . LJ::ljuser($u) if $u;
        } elsif ($row->{action} eq 'friend_invite_sent') {
            $action = "Friend invite sent to $extra->{extra}";
        } elsif ($row->{action} eq 'maintainer_add') {
            my $u = LJ::load_userid($row->{actiontarget});
            $action = "Added maintainer " . LJ::ljuser($u) if $u;
        } elsif ($row->{action} eq 'maintainer_remove') {
            my $u = LJ::load_userid($row->{actiontarget});
            $action = "Removed maintainer " . LJ::ljuser($u) if $u;
        } elsif ($row->{action} eq 'emailpost') {
            $action = "User posted via email gateway";
        } elsif ($row->{action} eq 'set_owner') {
            my $userid = $row->{actiontarget};
            my $u = LJ::load_userid ($userid);
            $action = "User ".LJ::ljuser($u)." set as supermaintainer";
        } elsif ($row->{action} eq 'accountstatus') {
            my $path = "$extra->{old} -> $extra->{new}";
            $action = {
                    'V -> D' => "Account deleted",
                    'D -> V' => "Account undeleted",
                }->{$path} || "Account status changed ($extra->{old} to $extra->{new})";
        } elsif ($row->{action} eq 'password_change') {
            $action = "User changed password";
        } elsif ($row->{action} eq 'password_reset') {
            $action = "User reset password via lost password email";
        } elsif ($row->{action} eq 'email_change') {
            $action = "Email address changed to: ".$format_email->($extra->{'new'});
        } elsif ($row->{action} eq 'mass_privacy_change') {
            $action = "Entry privacy updated (from $extra->{s_security} to $extra->{e_security})";
            # TODO: parse out e_unixtime and s_unixtime and display?
        } elsif ($row->{action} eq 'delete_userpic') {
            $action = "Deleted userpic #$extra->{picid}";
        } elsif ($row->{action} eq 'pwd_reset_req') {
            my $email = $extra->{email};
            $email = $format_email->($email);
            my $email_state = {
                'A' => 'current, validated',
                'T' => 'current, transitioning',
                'N' => 'current, non-validated',
                'P' => 'previously-validated'
            }->{$extra->{email_state}};
            my $time = scalar(localtime($extra->{time}));
            $action = "Requested a password reset email to $email; $email_state; added on $time.";
        } elsif ($row->{action} eq 'spam_set') {
            my $u = LJ::load_userid($row->{actiontarget});
            $action = "Marked as spammer " . LJ::ljuser($u) if $u;
        } elsif ($row->{action} eq 'spam_unset') {
            my $u = LJ::load_userid($row->{actiontarget});
            $action = "Unmarked as spammer " . LJ::ljuser($u) if $u;
        } elsif (my $info = LJ::run_hook('userlog_rows', $row, $extra)) {
            $action = $info;
        } else {
            $action = "Unknown action ($row->{action})";
        }

        my $time = LJ::TimeUtil->mysql_time($row->{logtime});

        my $actor;
        if ($row->{remoteid}) {
            my $u = LJ::load_userid($row->{remoteid});
            $actor = LJ::ljuser($u);
        } else {
            $actor = "<em>not recorded</em>";
        }
        
        my ($ip, $uniq);
        if (!$can_view) {
            $ip = '***';
        } else {
            $ip = $row->{ip} || "<em>not recorded</em>"; 
        }			
        if (!$can_view && !$can_view_uniq) {
               $uniq = '***';
        } else {
            $uniq = ($row->{uniq}) 
                ? qq{<a href='$LJ::SITEROOT/admin/uniq.bml?what=$row->{uniq}'> $row->{uniq} </a>} 
                : "<em>not recorded</em>";
        }

        $ret .= "<tr>" . join('', map { "<td class='logrow'>$_</td>" } ($time, $action, $actor, $ip, $uniq)) . "</tr>\n";
        last if $account_creation;
    }

    $ret .= "</table>";
    return $ret;
}
_code?>
<=body
page?>
