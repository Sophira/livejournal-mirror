#!/usr/bin/perl
#

BEGIN {
    unshift @INC, "$ENV{'LJHOME'}/cgi-bin";
}

use strict;
use FCGI;
use LJ::Cache;

require "$ENV{'LJHOME'}/cgi-bin/ljlib.pl";

my $CACHE_SIZE = $LJ::USERPIC_CACHE_SIZE || 500;

my $dbs = LJ::get_dbs();
my $dbh = $dbs->{'dbh'};
my $dro = $dbs->{'reader'};

sub make_dir
{
    my $d = shift;
    return if (-d $d);
    mkdir $d, 0777;
}

my $CACHE_DIR = "$ENV{'LJHOME'}/htdocs/userpics";
my $USE_DISK_CACHE = -d $CACHE_DIR;
my $cache = $USE_DISK_CACHE ? undef : new LJ::Cache { 'maxsize' => $CACHE_SIZE };

my $hits = 0;
my $misses = 0;
my $ifmodsince = 0;    # if we just said "No" to "If-Modified-Since" HTTP header
my $timestart = time();
my %from;
my %reqmeth;
my $lastconn;
my $sth;

my $err = sub {
    my $status = shift;
    my $msg = shift;
    my $smsg = $status eq "404" ? "Not Found" : "Server Error";
    print "Status: $status $smsg\n";
    print "Content-type: text/html\n\n<b>Error:</b> $msg\n";
    return 0;
};

 REQUEST:
    while(LJ::start_request() && FCGI::accept() >= 0) 
{
    if ($ENV{'HTTP_IF_MODIFIED_SINCE'}) {
	# we can safely do this without checking since we never re-use
	# picture IDs and don't let the contents get modified
	$ifmodsince++;
	print "Status: 304 Not Modified\n\n";
	next REQUEST;
    }

    my $now = time();
    my %FORM = ();
    LJ::get_form_data(\%FORM, "GET");
    if ($ENV{'PATH_INFO'} =~ /^\/(\w+)$/) {
	$FORM{'id'} = $1;
    }
    $reqmeth{$ENV{'REQUEST_METHOD'}}++;

    if ($FORM{'id'} =~ /^info/) {
	print "Content-type: text/html\n\n<h1>userpic stats</h1>";
	unless ($cache) {
	    print "(in disk cache mode; no stats available)";
	    next REQUEST;
	}

	print "<PRE>";
	my $pid = $$;
	my $cached = $cache->{'size'};
	print  " cached: $cached\n";
	my $total = $hits + $misses + $ifmodsince;
	$total ||= 1;
	printf "   hits: $hits\t(%.1f%%)\n", ($hits*100/$total);
	printf " misses: $misses\t(%.1f%%)\n", ($misses*100/$total);
	printf "not mod: $ifmodsince\t(%.1f%%)\n", ($ifmodsince*100/$total);
	print "Request methods:\n";
	foreach (sort keys %reqmeth) {
	    print "  $_ = $reqmeth{$_}\n";
	}
	print "Fetch source:\n";
	foreach (keys %from) {
	    print "  $_ = $from{$_}\n";
	}

	print "pid: $$\n";
	print "USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND\n";
	foreach (split(/\n/, `ps auwx | grep $pid`)) {
	    next if ($_ =~ m/grep/);
	    print $_, "\n";
	}
	print "</PRE>";

	my $show = 400;
	print "<h2>first $show of $cached cache entries:</h2>\n";
	print "with seconds alive in cache shown in parentheses.<BR>";
	print "<A HREF=\"/userpic/info?sort=recent\">[sort by recently hit]</A> ";
	print "<A HREF=\"/userpic/info?sort=time\">[sort by time in cache]</A> ";
	print "<P>";

	my @items = ();

	my $iter = $cache->{'head'};
	while (defined $iter) {
	    my $node = $cache->{'items'}->{$iter};
	    my $item = $node->[1];
	    push @items, { 'id' => $iter, 
			   'time' => $item->{'time'},
		       };
	    $iter = $node->[2];
	}
	
	if ($FORM{'sort'} eq "time") {
	    @items = sort { $a->{'time'} <=> $b->{'time'} } @items;
	}
	my $count = 0;
	foreach my $it (@items) {
	    if ($count++ == $show) { last; }
	    my $age = $now - $it->{'time'};
	    print "<a href=\"/userpic/$it->{'id'}\">$it->{'id'}</a> ($age), ";
	}

	next REQUEST;
    }

    unless ($FORM{'id'} =~ /^\d+$/) {
        $err->(404, "The requested image was not found.");
	next REQUEST;
    }

    my $qid = $FORM{'id'} + 0;
    my $pic = $cache ? $cache->get($qid) : undef;

    my $cache_file;
    my $on_disk;
    my @s;
    my @dirs_make;
    if ($USE_DISK_CACHE) {
	if ($qid =~ /^\d*(\d\d)(\d\d\d)$/) {
	    push @dirs_make, ("$CACHE_DIR/$2",
			      "$CACHE_DIR/$2/$1");
	    $cache_file = "$CACHE_DIR/$2/$1/$qid";
	} else {
	    my $mod = sprintf("%03d", $qid % 1000);
	    push @dirs_make, "$CACHE_DIR/$mod";
	    $cache_file = "$CACHE_DIR/$mod/p$qid"; # p to prevent dir name clash
	}
	@s = stat($cache_file);
	$on_disk = $s[7];
    }

    if (! defined $pic || ! $on_disk)
    {
	$misses++;

	## every 10 seconds, revalidate/reconnect our db connections
	if (($now - $lastconn) > 10) {
            $dbs = LJ::get_dbs();
	    $dbh = $dbs->{'dbh'};
	    $dro = $dbs->{'reader'};
	    $lastconn = $now;
	}

        unless ($dro) {
            $err->(500, "Database temporarily unavailable.");
            next REQUEST;
        }

	my $query = "SELECT p.state, p.userid, p.contenttype, UNIX_TIMESTAMP(p.picdate) ".
            "AS 'lastmod', u.clusterid, u.dversion FROM userpic p, user u WHERE ".
            "p.picid=$qid AND u.userid=p.userid";

        my $imagedata;
        if (defined $pic) { $imagedata = $pic->{'imagedata'}; }
        $pic = LJ::dbs_selectrow_hashref($dbs, $query);

	## either we don't have a slave database, or it's not caught up yet. try the master now.
	if (! defined $pic) {
            $err->(404, "No userpic by that id.");
            next REQUEST;
	}

        unless ($pic->{'imagedata'} || $imagedata) 
        {
            if ($pic->{'dversion'} >= 2) { 
                my $dbb = LJ::get_cluster_reader($pic->{'clusterid'});
                unless ($dbb) {
                    $err->(500, "Database temporarily unavailable.");
                    next REQUEST;
                }
                $imagedata = $dbb->selectrow_array("SELECT imagedata FROM userpicblob2 WHERE ".
                                                   "userid=$pic->{'userid'} AND picid=$qid");
            } else {
                $imagedata = $dro->selectrow_array("SELECT imagedata FROM userpicblob WHERE ".
                                                   "picid=$qid");
            }
        }

        $pic->{'imagedata'} = $imagedata if $imagedata;
	if ($pic->{'state'} eq "B") { $pic->{'imagedata'} = "x"; }
	$pic->{'length'} = length($pic->{'imagedata'});
	$pic->{'time'} = time();

	# store the picture on disk, not in memory
	if ($USE_DISK_CACHE) {
	    if ($on_disk) {
		# touch it if modify time is older than a day, to keep it in
		# disk cache for tomorrow.
		if ($s[9] < time()-86400) {  
		    open (ID, ">>$cache_file");
		    close ID;
		}
	    } elsif ($cache_file && $pic->{'imagedata'}) {
		foreach (@dirs_make) { make_dir($_); }
		open (ID, ">$cache_file");
		binmode (ID);  # for windows users
		print ID $pic->{'imagedata'};
		close ID;
	    }
	}
    } else {
	$hits++;
    }

    if ($pic && ! $pic->{'imagedata'}) {
	open (ID, $cache_file);
	while (<ID>) {
	    $pic->{'imagedata'} .= $_;
	}
	close ID;
	$pic->{'length'} = length($pic->{'imagedata'});	    
    }

    $cache->set($qid, $pic) if $cache;

    if ($pic && $pic->{'length'})
    {
	print "Content-type: $pic->{'contenttype'}\n";
	print "Content-length: $pic->{'length'}\n";
	print "Cache-Control: no-transform\n";
	print "Expires: ", LJ::time_to_http(time()+3000000), "\n"; # in 3-4 months
	print "Last-Modified: ", LJ::time_to_http($pic->{'lastmod'}), "\n";
	print "\n";
	unless ($ENV{'REQUEST_METHOD'} eq "HEAD") {
	    print $pic->{'imagedata'};
	}
	delete $pic->{'imagedata'} if $USE_DISK_CACHE;
    } else {
	print "Status: 404 Not Found\n";
	print "Content-type: text/html\n\n";
	print "<h1>Not Found</h1>The requested image was not found.";
	print "\n";
    }
}
